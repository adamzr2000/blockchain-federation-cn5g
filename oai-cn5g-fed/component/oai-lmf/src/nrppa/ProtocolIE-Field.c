/*
 * Generated by asn1c-0.9.29 (http://lionet.info/asn1c)
 * From ASN.1 module "NRPPA-Containers"
 * 	found in "38455.asn"
 * 	`asn1c -no-gen-OER -fcompound-names -no-gen-example -findirect-choice
 * -fno-include-deps -D nrppa`
 */

#include "ProtocolIE-Field.h"

static const long asn_VAL_27_id_OTDOA_Information_Type_Item            = 10;
static const long asn_VAL_27_reject                                    = 0;
static const long asn_VAL_27_mandatory                                 = 2;
static const asn_ioc_cell_t asn_IOS_OTDOA_Information_TypeIEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_27_id_OTDOA_Information_Type_Item},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_27_reject},
    {"&Value", aioc__type, &asn_DEF_OTDOA_Information_Type_Item},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_27_mandatory}};
static const asn_ioc_set_t asn_IOS_OTDOA_Information_TypeIEs_1[] = {
    {1, 4, asn_IOS_OTDOA_Information_TypeIEs_1_rows}};
static const long asn_VAL_90_id_MeasurementQuantities_Item                 = 11;
static const long asn_VAL_90_reject                                        = 0;
static const long asn_VAL_90_mandatory                                     = 2;
static const asn_ioc_cell_t asn_IOS_MeasurementQuantities_ItemIEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_90_id_MeasurementQuantities_Item},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_90_reject},
    {"&Value", aioc__type, &asn_DEF_MeasurementQuantities_Item},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_90_mandatory}};
static const asn_ioc_set_t asn_IOS_MeasurementQuantities_ItemIEs_1[] = {
    {1, 4, asn_IOS_MeasurementQuantities_ItemIEs_1_rows}};
static const long asn_VAL_91_id_ResultSS_RSRP    = 32;
static const long asn_VAL_91_ignore              = 1;
static const long asn_VAL_91_mandatory           = 2;
static const long asn_VAL_92_id_ResultSS_RSRQ    = 33;
static const long asn_VAL_92_ignore              = 1;
static const long asn_VAL_92_mandatory           = 2;
static const long asn_VAL_93_id_ResultCSI_RSRP   = 34;
static const long asn_VAL_93_ignore              = 1;
static const long asn_VAL_93_mandatory           = 2;
static const long asn_VAL_94_id_ResultCSI_RSRQ   = 35;
static const long asn_VAL_94_ignore              = 1;
static const long asn_VAL_94_mandatory           = 2;
static const long asn_VAL_95_id_AngleOfArrivalNR = 36;
static const long asn_VAL_95_ignore              = 1;
static const long asn_VAL_95_mandatory           = 2;
static const asn_ioc_cell_t asn_IOS_MeasuredResultsValue_ExtensionIE_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_91_id_ResultSS_RSRP},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_91_ignore},
     {"&Value", aioc__type, &asn_DEF_ResultSS_RSRP},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_91_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_92_id_ResultSS_RSRQ},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_92_ignore},
     {"&Value", aioc__type, &asn_DEF_ResultSS_RSRQ},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_92_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_93_id_ResultCSI_RSRP},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_93_ignore},
     {"&Value", aioc__type, &asn_DEF_ResultCSI_RSRP},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_93_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_94_id_ResultCSI_RSRQ},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_94_ignore},
     {"&Value", aioc__type, &asn_DEF_ResultCSI_RSRQ},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_94_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_95_id_AngleOfArrivalNR},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_95_ignore},
     {"&Value", aioc__type, &asn_DEF_UL_AoA},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_95_mandatory}};
static const asn_ioc_set_t asn_IOS_MeasuredResultsValue_ExtensionIE_1[] = {
    {5, 4, asn_IOS_MeasuredResultsValue_ExtensionIE_1_rows}};
static const long asn_VAL_96_id_TDD_Config_EUTRA_Item = 22;
static const long asn_VAL_96_ignore                   = 1;
static const long asn_VAL_96_optional                 = 0;
static const asn_ioc_cell_t
    asn_IOS_OTDOACell_Information_Item_ExtensionIE_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_96_id_TDD_Config_EUTRA_Item},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_96_ignore},
        {"&Value", aioc__type, &asn_DEF_TDD_Config_EUTRA_Item},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_96_optional}};
static const asn_ioc_set_t asn_IOS_OTDOACell_Information_Item_ExtensionIE_1[] =
    {{1, 4, asn_IOS_OTDOACell_Information_Item_ExtensionIE_1_rows}};
static const long asn_VAL_97_id_OtherRATMeasurementQuantities_Item = 16;
static const long asn_VAL_97_reject                                = 0;
static const long asn_VAL_97_mandatory                             = 2;
static const asn_ioc_cell_t
    asn_IOS_OtherRATMeasurementQuantities_ItemIEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_97_id_OtherRATMeasurementQuantities_Item},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_97_reject},
        {"&Value", aioc__type, &asn_DEF_OtherRATMeasurementQuantities_Item},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_97_mandatory}};
static const asn_ioc_set_t asn_IOS_OtherRATMeasurementQuantities_ItemIEs_1[] = {
    {1, 4, asn_IOS_OtherRATMeasurementQuantities_ItemIEs_1_rows}};
static const long asn_VAL_98_id_ResultNR    = 55;
static const long asn_VAL_98_ignore         = 1;
static const long asn_VAL_98_mandatory      = 2;
static const long asn_VAL_99_id_ResultEUTRA = 56;
static const long asn_VAL_99_ignore         = 1;
static const long asn_VAL_99_mandatory      = 2;
static const asn_ioc_cell_t
    asn_IOS_OtherRATMeasuredResultsValue_ExtensionIE_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_98_id_ResultNR},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_98_ignore},
        {"&Value", aioc__type, &asn_DEF_ResultNR},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_98_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_99_id_ResultEUTRA},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_99_ignore},
        {"&Value", aioc__type, &asn_DEF_ResultEUTRA},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_99_mandatory}};
static const asn_ioc_set_t
    asn_IOS_OtherRATMeasuredResultsValue_ExtensionIE_1[] = {
        {2, 4, asn_IOS_OtherRATMeasuredResultsValue_ExtensionIE_1_rows}};
static const long asn_VAL_100_id_WLANMeasurementQuantities_Item = 20;
static const long asn_VAL_100_reject                            = 0;
static const long asn_VAL_100_mandatory                         = 2;
static const asn_ioc_cell_t asn_IOS_WLANMeasurementQuantities_ItemIEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_100_id_WLANMeasurementQuantities_Item},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_100_reject},
     {"&Value", aioc__type, &asn_DEF_WLANMeasurementQuantities_Item},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_100_mandatory}};
static const asn_ioc_set_t asn_IOS_WLANMeasurementQuantities_ItemIEs_1[] = {
    {1, 4, asn_IOS_WLANMeasurementQuantities_ItemIEs_1_rows}};
static const long asn_VAL_1_id_LMF_UE_Measurement_ID         = 2;
static const long asn_VAL_1_reject                           = 0;
static const long asn_VAL_1_mandatory                        = 2;
static const long asn_VAL_2_id_ReportCharacteristics         = 3;
static const long asn_VAL_2_reject                           = 0;
static const long asn_VAL_2_mandatory                        = 2;
static const long asn_VAL_3_id_MeasurementPeriodicity        = 4;
static const long asn_VAL_3_reject                           = 0;
static const long asn_VAL_3_conditional                      = 1;
static const long asn_VAL_4_id_MeasurementQuantities         = 5;
static const long asn_VAL_4_reject                           = 0;
static const long asn_VAL_4_mandatory                        = 2;
static const long asn_VAL_5_id_OtherRATMeasurementQuantities = 15;
static const long asn_VAL_5_ignore                           = 1;
static const long asn_VAL_5_optional                         = 0;
static const long asn_VAL_6_id_WLANMeasurementQuantities     = 19;
static const long asn_VAL_6_ignore                           = 1;
static const long asn_VAL_6_optional                         = 0;
static const asn_ioc_cell_t
    asn_IOS_E_CIDMeasurementInitiationRequest_IEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_1_id_LMF_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_1_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_1_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_2_id_ReportCharacteristics},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_2_reject},
        {"&Value", aioc__type, &asn_DEF_ReportCharacteristics},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_2_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_3_id_MeasurementPeriodicity},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_3_reject},
        {"&Value", aioc__type, &asn_DEF_MeasurementPeriodicity},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_3_conditional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_4_id_MeasurementQuantities},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_4_reject},
        {"&Value", aioc__type, &asn_DEF_MeasurementQuantities},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_4_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_5_id_OtherRATMeasurementQuantities},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_5_ignore},
        {"&Value", aioc__type, &asn_DEF_OtherRATMeasurementQuantities},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_5_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_6_id_WLANMeasurementQuantities},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_6_ignore},
        {"&Value", aioc__type, &asn_DEF_WLANMeasurementQuantities},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_6_optional}};
static const asn_ioc_set_t asn_IOS_E_CIDMeasurementInitiationRequest_IEs_1[] = {
    {6, 4, asn_IOS_E_CIDMeasurementInitiationRequest_IEs_1_rows}};
static const long asn_VAL_7_id_LMF_UE_Measurement_ID      = 2;
static const long asn_VAL_7_reject                        = 0;
static const long asn_VAL_7_mandatory                     = 2;
static const long asn_VAL_8_id_RAN_UE_Measurement_ID      = 6;
static const long asn_VAL_8_reject                        = 0;
static const long asn_VAL_8_mandatory                     = 2;
static const long asn_VAL_9_id_E_CID_MeasurementResult    = 7;
static const long asn_VAL_9_ignore                        = 1;
static const long asn_VAL_9_optional                      = 0;
static const long asn_VAL_10_id_CriticalityDiagnostics    = 1;
static const long asn_VAL_10_ignore                       = 1;
static const long asn_VAL_10_optional                     = 0;
static const long asn_VAL_11_id_Cell_Portion_ID           = 14;
static const long asn_VAL_11_ignore                       = 1;
static const long asn_VAL_11_optional                     = 0;
static const long asn_VAL_12_id_OtherRATMeasurementResult = 17;
static const long asn_VAL_12_ignore                       = 1;
static const long asn_VAL_12_optional                     = 0;
static const long asn_VAL_13_id_WLANMeasurementResult     = 21;
static const long asn_VAL_13_ignore                       = 1;
static const long asn_VAL_13_optional                     = 0;
static const asn_ioc_cell_t
    asn_IOS_E_CIDMeasurementInitiationResponse_IEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_7_id_LMF_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_7_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_7_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_8_id_RAN_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_8_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_8_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_9_id_E_CID_MeasurementResult},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_9_ignore},
        {"&Value", aioc__type, &asn_DEF_E_CID_MeasurementResult},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_9_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_10_id_CriticalityDiagnostics},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_10_ignore},
        {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_10_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_11_id_Cell_Portion_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_11_ignore},
        {"&Value", aioc__type, &asn_DEF_Cell_Portion_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_11_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_12_id_OtherRATMeasurementResult},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_12_ignore},
        {"&Value", aioc__type, &asn_DEF_OtherRATMeasurementResult},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_12_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_13_id_WLANMeasurementResult},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_13_ignore},
        {"&Value", aioc__type, &asn_DEF_WLANMeasurementResult},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_13_optional}};
static const asn_ioc_set_t asn_IOS_E_CIDMeasurementInitiationResponse_IEs_1[] =
    {{7, 4, asn_IOS_E_CIDMeasurementInitiationResponse_IEs_1_rows}};
static const long asn_VAL_14_id_LMF_UE_Measurement_ID  = 2;
static const long asn_VAL_14_reject                    = 0;
static const long asn_VAL_14_mandatory                 = 2;
static const long asn_VAL_15_id_Cause                  = 0;
static const long asn_VAL_15_ignore                    = 1;
static const long asn_VAL_15_mandatory                 = 2;
static const long asn_VAL_16_id_CriticalityDiagnostics = 1;
static const long asn_VAL_16_ignore                    = 1;
static const long asn_VAL_16_optional                  = 0;
static const asn_ioc_cell_t
    asn_IOS_E_CIDMeasurementInitiationFailure_IEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_14_id_LMF_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_14_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_14_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_15_id_Cause},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_15_ignore},
        {"&Value", aioc__type, &asn_DEF_Cause},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_15_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_16_id_CriticalityDiagnostics},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_16_ignore},
        {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_16_optional}};
static const asn_ioc_set_t asn_IOS_E_CIDMeasurementInitiationFailure_IEs_1[] = {
    {3, 4, asn_IOS_E_CIDMeasurementInitiationFailure_IEs_1_rows}};
static const long asn_VAL_17_id_LMF_UE_Measurement_ID = 2;
static const long asn_VAL_17_reject                   = 0;
static const long asn_VAL_17_mandatory                = 2;
static const long asn_VAL_18_id_RAN_UE_Measurement_ID = 6;
static const long asn_VAL_18_reject                   = 0;
static const long asn_VAL_18_mandatory                = 2;
static const long asn_VAL_19_id_Cause                 = 0;
static const long asn_VAL_19_ignore                   = 1;
static const long asn_VAL_19_mandatory                = 2;
static const asn_ioc_cell_t
    asn_IOS_E_CIDMeasurementFailureIndication_IEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_17_id_LMF_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_17_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_17_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_18_id_RAN_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_18_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_18_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_19_id_Cause},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_19_ignore},
        {"&Value", aioc__type, &asn_DEF_Cause},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_19_mandatory}};
static const asn_ioc_set_t asn_IOS_E_CIDMeasurementFailureIndication_IEs_1[] = {
    {3, 4, asn_IOS_E_CIDMeasurementFailureIndication_IEs_1_rows}};
static const long asn_VAL_20_id_LMF_UE_Measurement_ID                   = 2;
static const long asn_VAL_20_reject                                     = 0;
static const long asn_VAL_20_mandatory                                  = 2;
static const long asn_VAL_21_id_RAN_UE_Measurement_ID                   = 6;
static const long asn_VAL_21_reject                                     = 0;
static const long asn_VAL_21_mandatory                                  = 2;
static const long asn_VAL_22_id_E_CID_MeasurementResult                 = 7;
static const long asn_VAL_22_ignore                                     = 1;
static const long asn_VAL_22_mandatory                                  = 2;
static const long asn_VAL_23_id_Cell_Portion_ID                         = 14;
static const long asn_VAL_23_ignore                                     = 1;
static const long asn_VAL_23_optional                                   = 0;
static const asn_ioc_cell_t asn_IOS_E_CIDMeasurementReport_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_20_id_LMF_UE_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_20_reject},
    {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_20_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_21_id_RAN_UE_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_21_reject},
    {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_21_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_22_id_E_CID_MeasurementResult},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_22_ignore},
    {"&Value", aioc__type, &asn_DEF_E_CID_MeasurementResult},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_22_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_23_id_Cell_Portion_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_23_ignore},
    {"&Value", aioc__type, &asn_DEF_Cell_Portion_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_23_optional}};
static const asn_ioc_set_t asn_IOS_E_CIDMeasurementReport_IEs_1[] = {
    {4, 4, asn_IOS_E_CIDMeasurementReport_IEs_1_rows}};
static const long asn_VAL_24_id_LMF_UE_Measurement_ID = 2;
static const long asn_VAL_24_reject                   = 0;
static const long asn_VAL_24_mandatory                = 2;
static const long asn_VAL_25_id_RAN_UE_Measurement_ID = 6;
static const long asn_VAL_25_reject                   = 0;
static const long asn_VAL_25_mandatory                = 2;
static const asn_ioc_cell_t
    asn_IOS_E_CIDMeasurementTerminationCommand_IEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_24_id_LMF_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_24_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_24_mandatory},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_25_id_RAN_UE_Measurement_ID},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_25_reject},
        {"&Value", aioc__type, &asn_DEF_UE_Measurement_ID},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_25_mandatory}};
static const asn_ioc_set_t asn_IOS_E_CIDMeasurementTerminationCommand_IEs_1[] =
    {{2, 4, asn_IOS_E_CIDMeasurementTerminationCommand_IEs_1_rows}};
static const long asn_VAL_26_id_OTDOA_Information_Type_Group             = 9;
static const long asn_VAL_26_reject                                      = 0;
static const long asn_VAL_26_mandatory                                   = 2;
static const asn_ioc_cell_t asn_IOS_OTDOAInformationRequest_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_26_id_OTDOA_Information_Type_Group},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_26_reject},
    {"&Value", aioc__type, &asn_DEF_OTDOA_Information_Type},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_26_mandatory}};
static const asn_ioc_set_t asn_IOS_OTDOAInformationRequest_IEs_1[] = {
    {1, 4, asn_IOS_OTDOAInformationRequest_IEs_1_rows}};
static const long asn_VAL_28_id_OTDOACells                                = 8;
static const long asn_VAL_28_ignore                                       = 1;
static const long asn_VAL_28_mandatory                                    = 2;
static const long asn_VAL_29_id_CriticalityDiagnostics                    = 1;
static const long asn_VAL_29_ignore                                       = 1;
static const long asn_VAL_29_optional                                     = 0;
static const asn_ioc_cell_t asn_IOS_OTDOAInformationResponse_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_28_id_OTDOACells},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_28_ignore},
    {"&Value", aioc__type, &asn_DEF_OTDOACells},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_28_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_29_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_29_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_29_optional}};
static const asn_ioc_set_t asn_IOS_OTDOAInformationResponse_IEs_1[] = {
    {2, 4, asn_IOS_OTDOAInformationResponse_IEs_1_rows}};
static const long asn_VAL_30_id_Cause                                    = 0;
static const long asn_VAL_30_ignore                                      = 1;
static const long asn_VAL_30_mandatory                                   = 2;
static const long asn_VAL_31_id_CriticalityDiagnostics                   = 1;
static const long asn_VAL_31_ignore                                      = 1;
static const long asn_VAL_31_optional                                    = 0;
static const asn_ioc_cell_t asn_IOS_OTDOAInformationFailure_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_30_id_Cause},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_30_ignore},
    {"&Value", aioc__type, &asn_DEF_Cause},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_30_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_31_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_31_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_31_optional}};
static const asn_ioc_set_t asn_IOS_OTDOAInformationFailure_IEs_1[] = {
    {2, 4, asn_IOS_OTDOAInformationFailure_IEs_1_rows}};
static const long asn_VAL_32_id_Assistance_Information    = 23;
static const long asn_VAL_32_reject                       = 0;
static const long asn_VAL_32_optional                     = 0;
static const long asn_VAL_33_id_Broadcast                 = 24;
static const long asn_VAL_33_reject                       = 0;
static const long asn_VAL_33_optional                     = 0;
static const long asn_VAL_34_id_PositioningBroadcastCells = 38;
static const long asn_VAL_34_reject                       = 0;
static const long asn_VAL_34_optional                     = 0;
static const asn_ioc_cell_t asn_IOS_AssistanceInformationControl_IEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_32_id_Assistance_Information},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_32_reject},
     {"&Value", aioc__type, &asn_DEF_Assistance_Information},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_32_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_33_id_Broadcast},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_33_reject},
     {"&Value", aioc__type, &asn_DEF_Broadcast},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_33_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_34_id_PositioningBroadcastCells},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_34_reject},
     {"&Value", aioc__type, &asn_DEF_PositioningBroadcastCells},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_34_optional}};
static const asn_ioc_set_t asn_IOS_AssistanceInformationControl_IEs_1[] = {
    {3, 4, asn_IOS_AssistanceInformationControl_IEs_1_rows}};
static const long asn_VAL_35_id_AssistanceInformationFailureList = 25;
static const long asn_VAL_35_reject                              = 0;
static const long asn_VAL_35_optional                            = 0;
static const long asn_VAL_36_id_PositioningBroadcastCells        = 38;
static const long asn_VAL_36_reject                              = 0;
static const long asn_VAL_36_optional                            = 0;
static const long asn_VAL_37_id_CriticalityDiagnostics           = 1;
static const long asn_VAL_37_ignore                              = 1;
static const long asn_VAL_37_optional                            = 0;
static const asn_ioc_cell_t asn_IOS_AssistanceInformationFeedback_IEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_35_id_AssistanceInformationFailureList},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_35_reject},
     {"&Value", aioc__type, &asn_DEF_AssistanceInformationFailureList},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_35_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_36_id_PositioningBroadcastCells},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_36_reject},
     {"&Value", aioc__type, &asn_DEF_PositioningBroadcastCells},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_36_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_37_id_CriticalityDiagnostics},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_37_ignore},
     {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_37_optional}};
static const asn_ioc_set_t asn_IOS_AssistanceInformationFeedback_IEs_1[] = {
    {3, 4, asn_IOS_AssistanceInformationFeedback_IEs_1_rows}};
static const long asn_VAL_38_id_Cause                            = 0;
static const long asn_VAL_38_ignore                              = 1;
static const long asn_VAL_38_optional                            = 0;
static const long asn_VAL_39_id_CriticalityDiagnostics           = 1;
static const long asn_VAL_39_ignore                              = 1;
static const long asn_VAL_39_optional                            = 0;
static const asn_ioc_cell_t asn_IOS_ErrorIndication_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_38_id_Cause},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_38_ignore},
    {"&Value", aioc__type, &asn_DEF_Cause},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_38_optional},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_39_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_39_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_39_optional}};
static const asn_ioc_set_t asn_IOS_ErrorIndication_IEs_1[] = {
    {2, 4, asn_IOS_ErrorIndication_IEs_1_rows}};
static const long asn_VAL_40_id_RequestedSRSTransmissionCharacteristics = 12;
static const long asn_VAL_40_ignore                                     = 1;
static const long asn_VAL_40_optional                                   = 0;
static const asn_ioc_cell_t asn_IOS_PositioningInformationRequest_IEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_40_id_RequestedSRSTransmissionCharacteristics},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_40_ignore},
     {"&Value", aioc__type, &asn_DEF_RequestedSRSTransmissionCharacteristics},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_40_optional}};
static const asn_ioc_set_t asn_IOS_PositioningInformationRequest_IEs_1[] = {
    {1, 4, asn_IOS_PositioningInformationRequest_IEs_1_rows}};
static const long asn_VAL_41_id_SRSConfiguration       = 26;
static const long asn_VAL_41_ignore                    = 1;
static const long asn_VAL_41_optional                  = 0;
static const long asn_VAL_42_id_SFNInitialisationTime  = 54;
static const long asn_VAL_42_ignore                    = 1;
static const long asn_VAL_42_optional                  = 0;
static const long asn_VAL_43_id_CriticalityDiagnostics = 1;
static const long asn_VAL_43_ignore                    = 1;
static const long asn_VAL_43_optional                  = 0;
static const asn_ioc_cell_t
    asn_IOS_PositioningInformationResponse_IEs_1_rows[] = {
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_41_id_SRSConfiguration},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_41_ignore},
        {"&Value", aioc__type, &asn_DEF_SRSConfiguration},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_41_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_42_id_SFNInitialisationTime},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_42_ignore},
        {"&Value", aioc__type, &asn_DEF_SFNInitialisationTime},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_42_optional},
        {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
         &asn_VAL_43_id_CriticalityDiagnostics},
        {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_43_ignore},
        {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
        {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_43_optional}};
static const asn_ioc_set_t asn_IOS_PositioningInformationResponse_IEs_1[] = {
    {3, 4, asn_IOS_PositioningInformationResponse_IEs_1_rows}};
static const long asn_VAL_44_id_Cause                  = 0;
static const long asn_VAL_44_ignore                    = 1;
static const long asn_VAL_44_mandatory                 = 2;
static const long asn_VAL_45_id_CriticalityDiagnostics = 1;
static const long asn_VAL_45_ignore                    = 1;
static const long asn_VAL_45_optional                  = 0;
static const asn_ioc_cell_t asn_IOS_PositioningInformationFailure_IEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_44_id_Cause},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_44_ignore},
     {"&Value", aioc__type, &asn_DEF_Cause},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_44_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_45_id_CriticalityDiagnostics},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_45_ignore},
     {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_45_optional}};
static const asn_ioc_set_t asn_IOS_PositioningInformationFailure_IEs_1[] = {
    {2, 4, asn_IOS_PositioningInformationFailure_IEs_1_rows}};
static const long asn_VAL_46_id_SRSConfiguration      = 26;
static const long asn_VAL_46_ignore                   = 1;
static const long asn_VAL_46_optional                 = 0;
static const long asn_VAL_47_id_SFNInitialisationTime = 54;
static const long asn_VAL_47_ignore                   = 1;
static const long asn_VAL_47_optional                 = 0;
static const asn_ioc_cell_t asn_IOS_PositioningInformationUpdate_IEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_46_id_SRSConfiguration},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_46_ignore},
     {"&Value", aioc__type, &asn_DEF_SRSConfiguration},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_46_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_47_id_SFNInitialisationTime},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_47_ignore},
     {"&Value", aioc__type, &asn_DEF_SFNInitialisationTime},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_47_optional}};
static const asn_ioc_set_t asn_IOS_PositioningInformationUpdate_IEs_1[] = {
    {2, 4, asn_IOS_PositioningInformationUpdate_IEs_1_rows}};
static const long asn_VAL_48_id_LMF_Measurement_ID                  = 39;
static const long asn_VAL_48_reject                                 = 0;
static const long asn_VAL_48_mandatory                              = 2;
static const long asn_VAL_49_id_TRP_MeasurementRequestList          = 41;
static const long asn_VAL_49_reject                                 = 0;
static const long asn_VAL_49_mandatory                              = 2;
static const long asn_VAL_50_id_ReportCharacteristics               = 3;
static const long asn_VAL_50_reject                                 = 0;
static const long asn_VAL_50_mandatory                              = 2;
static const long asn_VAL_51_id_MeasurementPeriodicity              = 4;
static const long asn_VAL_51_reject                                 = 0;
static const long asn_VAL_51_conditional                            = 1;
static const long asn_VAL_52_id_TRPMeasurementQuantities            = 52;
static const long asn_VAL_52_reject                                 = 0;
static const long asn_VAL_52_mandatory                              = 2;
static const long asn_VAL_53_id_SRSConfiguration                    = 26;
static const long asn_VAL_53_ignore                                 = 1;
static const long asn_VAL_53_optional                               = 0;
static const long asn_VAL_54_id_SFNInitialisationTime               = 54;
static const long asn_VAL_54_ignore                                 = 1;
static const long asn_VAL_54_optional                               = 0;
static const long asn_VAL_55_id_MeasurementBeamInfoRequest          = 31;
static const long asn_VAL_55_ignore                                 = 1;
static const long asn_VAL_55_optional                               = 0;
static const long asn_VAL_56_id_SystemFrameNumber                   = 49;
static const long asn_VAL_56_ignore                                 = 1;
static const long asn_VAL_56_optional                               = 0;
static const long asn_VAL_57_id_SlotNumber                          = 50;
static const long asn_VAL_57_ignore                                 = 1;
static const long asn_VAL_57_optional                               = 0;
static const asn_ioc_cell_t asn_IOS_MeasurementRequest_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_48_id_LMF_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_48_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_48_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_49_id_TRP_MeasurementRequestList},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_49_reject},
    {"&Value", aioc__type, &asn_DEF_TRP_MeasurementRequestList},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_49_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_50_id_ReportCharacteristics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_50_reject},
    {"&Value", aioc__type, &asn_DEF_ReportCharacteristics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_50_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_51_id_MeasurementPeriodicity},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_51_reject},
    {"&Value", aioc__type, &asn_DEF_MeasurementPeriodicity},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_51_conditional},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_52_id_TRPMeasurementQuantities},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_52_reject},
    {"&Value", aioc__type, &asn_DEF_TRPMeasurementQuantities},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_52_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_53_id_SRSConfiguration},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_53_ignore},
    {"&Value", aioc__type, &asn_DEF_SRSConfiguration},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_53_optional},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_54_id_SFNInitialisationTime},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_54_ignore},
    {"&Value", aioc__type, &asn_DEF_SFNInitialisationTime},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_54_optional},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_55_id_MeasurementBeamInfoRequest},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_55_ignore},
    {"&Value", aioc__type, &asn_DEF_MeasurementBeamInfoRequest},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_55_optional},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_56_id_SystemFrameNumber},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_56_ignore},
    {"&Value", aioc__type, &asn_DEF_SystemFrameNumber},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_56_optional},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_57_id_SlotNumber},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_57_ignore},
    {"&Value", aioc__type, &asn_DEF_SlotNumber},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_57_optional}};
static const asn_ioc_set_t asn_IOS_MeasurementRequest_IEs_1[] = {
    {10, 4, asn_IOS_MeasurementRequest_IEs_1_rows}};
static const long asn_VAL_58_id_LMF_Measurement_ID                   = 39;
static const long asn_VAL_58_reject                                  = 0;
static const long asn_VAL_58_mandatory                               = 2;
static const long asn_VAL_59_id_RAN_Measurement_ID                   = 40;
static const long asn_VAL_59_reject                                  = 0;
static const long asn_VAL_59_mandatory                               = 2;
static const long asn_VAL_60_id_TRP_MeasurementResponseList          = 42;
static const long asn_VAL_60_reject                                  = 0;
static const long asn_VAL_60_mandatory                               = 2;
static const long asn_VAL_61_id_CriticalityDiagnostics               = 1;
static const long asn_VAL_61_ignore                                  = 1;
static const long asn_VAL_61_optional                                = 0;
static const asn_ioc_cell_t asn_IOS_MeasurementResponse_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_58_id_LMF_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_58_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_58_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_59_id_RAN_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_59_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_59_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_60_id_TRP_MeasurementResponseList},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_60_reject},
    {"&Value", aioc__type, &asn_DEF_TRP_MeasurementResponseList},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_60_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_61_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_61_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_61_optional}};
static const asn_ioc_set_t asn_IOS_MeasurementResponse_IEs_1[] = {
    {4, 4, asn_IOS_MeasurementResponse_IEs_1_rows}};
static const long asn_VAL_62_id_LMF_Measurement_ID                  = 39;
static const long asn_VAL_62_reject                                 = 0;
static const long asn_VAL_62_mandatory                              = 2;
static const long asn_VAL_63_id_Cause                               = 0;
static const long asn_VAL_63_ignore                                 = 1;
static const long asn_VAL_63_mandatory                              = 2;
static const long asn_VAL_64_id_CriticalityDiagnostics              = 1;
static const long asn_VAL_64_ignore                                 = 1;
static const long asn_VAL_64_optional                               = 0;
static const asn_ioc_cell_t asn_IOS_MeasurementFailure_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_62_id_LMF_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_62_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_62_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_63_id_Cause},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_63_ignore},
    {"&Value", aioc__type, &asn_DEF_Cause},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_63_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_64_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_64_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_64_optional}};
static const asn_ioc_set_t asn_IOS_MeasurementFailure_IEs_1[] = {
    {3, 4, asn_IOS_MeasurementFailure_IEs_1_rows}};
static const long asn_VAL_65_id_LMF_Measurement_ID                 = 39;
static const long asn_VAL_65_reject                                = 0;
static const long asn_VAL_65_mandatory                             = 2;
static const long asn_VAL_66_id_RAN_Measurement_ID                 = 40;
static const long asn_VAL_66_reject                                = 0;
static const long asn_VAL_66_mandatory                             = 2;
static const long asn_VAL_67_id_TRP_MeasurementReportList          = 43;
static const long asn_VAL_67_reject                                = 0;
static const long asn_VAL_67_mandatory                             = 2;
static const asn_ioc_cell_t asn_IOS_MeasurementReport_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_65_id_LMF_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_65_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_65_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_66_id_RAN_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_66_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_66_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_67_id_TRP_MeasurementReportList},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_67_reject},
    {"&Value", aioc__type, &asn_DEF_TRP_MeasurementResponseList},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_67_mandatory}};
static const asn_ioc_set_t asn_IOS_MeasurementReport_IEs_1[] = {
    {3, 4, asn_IOS_MeasurementReport_IEs_1_rows}};
static const long asn_VAL_68_id_LMF_Measurement_ID                 = 39;
static const long asn_VAL_68_reject                                = 0;
static const long asn_VAL_68_mandatory                             = 2;
static const long asn_VAL_69_id_RAN_Measurement_ID                 = 40;
static const long asn_VAL_69_reject                                = 0;
static const long asn_VAL_69_mandatory                             = 2;
static const long asn_VAL_70_id_SRSConfiguration                   = 26;
static const long asn_VAL_70_ignore                                = 1;
static const long asn_VAL_70_optional                              = 0;
static const asn_ioc_cell_t asn_IOS_MeasurementUpdate_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_68_id_LMF_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_68_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_68_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_69_id_RAN_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_69_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_69_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_70_id_SRSConfiguration},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_70_ignore},
    {"&Value", aioc__type, &asn_DEF_SRSConfiguration},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_70_optional}};
static const asn_ioc_set_t asn_IOS_MeasurementUpdate_IEs_1[] = {
    {3, 4, asn_IOS_MeasurementUpdate_IEs_1_rows}};
static const long asn_VAL_71_id_LMF_Measurement_ID                = 39;
static const long asn_VAL_71_reject                               = 0;
static const long asn_VAL_71_mandatory                            = 2;
static const long asn_VAL_72_id_RAN_Measurement_ID                = 40;
static const long asn_VAL_72_reject                               = 0;
static const long asn_VAL_72_mandatory                            = 2;
static const asn_ioc_cell_t asn_IOS_MeasurementAbort_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_71_id_LMF_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_71_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_71_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_72_id_RAN_Measurement_ID},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_72_reject},
    {"&Value", aioc__type, &asn_DEF_Measurement_ID},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_72_mandatory}};
static const asn_ioc_set_t asn_IOS_MeasurementAbort_IEs_1[] = {
    {2, 4, asn_IOS_MeasurementAbort_IEs_1_rows}};
static const long asn_VAL_73_id_LMF_Measurement_ID = 39;
static const long asn_VAL_73_reject                = 0;
static const long asn_VAL_73_mandatory             = 2;
static const long asn_VAL_74_id_RAN_Measurement_ID = 40;
static const long asn_VAL_74_reject                = 0;
static const long asn_VAL_74_mandatory             = 2;
static const long asn_VAL_75_id_Cause              = 0;
static const long asn_VAL_75_ignore                = 1;
static const long asn_VAL_75_mandatory             = 2;
static const asn_ioc_cell_t asn_IOS_MeasurementFailureIndication_IEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_73_id_LMF_Measurement_ID},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_73_reject},
     {"&Value", aioc__type, &asn_DEF_Measurement_ID},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_73_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_74_id_RAN_Measurement_ID},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_74_reject},
     {"&Value", aioc__type, &asn_DEF_Measurement_ID},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_74_mandatory},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_75_id_Cause},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_75_ignore},
     {"&Value", aioc__type, &asn_DEF_Cause},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_75_mandatory}};
static const asn_ioc_set_t asn_IOS_MeasurementFailureIndication_IEs_1[] = {
    {3, 4, asn_IOS_MeasurementFailureIndication_IEs_1_rows}};
static const long asn_VAL_76_id_TRPList                                = 47;
static const long asn_VAL_76_reject                                    = 0;
static const long asn_VAL_76_mandatory                                 = 2;
static const long asn_VAL_77_id_TRPInformationTypeList                 = 29;
static const long asn_VAL_77_reject                                    = 0;
static const long asn_VAL_77_mandatory                                 = 2;
static const asn_ioc_cell_t asn_IOS_TRPInformationRequest_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_76_id_TRPList},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_76_reject},
    {"&Value", aioc__type, &asn_DEF_TRPList},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_76_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_77_id_TRPInformationTypeList},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_77_reject},
    {"&Value", aioc__type, &asn_DEF_TRPInformationTypeList},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_77_mandatory}};
static const asn_ioc_set_t asn_IOS_TRPInformationRequest_IEs_1[] = {
    {2, 4, asn_IOS_TRPInformationRequest_IEs_1_rows}};
static const long asn_VAL_78_id_TRPInformationList                      = 30;
static const long asn_VAL_78_ignore                                     = 1;
static const long asn_VAL_78_mandatory                                  = 2;
static const long asn_VAL_79_id_CriticalityDiagnostics                  = 1;
static const long asn_VAL_79_ignore                                     = 1;
static const long asn_VAL_79_optional                                   = 0;
static const asn_ioc_cell_t asn_IOS_TRPInformationResponse_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_78_id_TRPInformationList},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_78_ignore},
    {"&Value", aioc__type, &asn_DEF_TRPInformationList},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_78_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_79_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_79_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_79_optional}};
static const asn_ioc_set_t asn_IOS_TRPInformationResponse_IEs_1[] = {
    {2, 4, asn_IOS_TRPInformationResponse_IEs_1_rows}};
static const long asn_VAL_80_id_Cause                                  = 0;
static const long asn_VAL_80_ignore                                    = 1;
static const long asn_VAL_80_mandatory                                 = 2;
static const long asn_VAL_81_id_CriticalityDiagnostics                 = 1;
static const long asn_VAL_81_ignore                                    = 1;
static const long asn_VAL_81_optional                                  = 0;
static const asn_ioc_cell_t asn_IOS_TRPInformationFailure_IEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_80_id_Cause},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_80_ignore},
    {"&Value", aioc__type, &asn_DEF_Cause},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_80_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_81_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_81_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_81_optional}};
static const asn_ioc_set_t asn_IOS_TRPInformationFailure_IEs_1[] = {
    {2, 4, asn_IOS_TRPInformationFailure_IEs_1_rows}};
static const long asn_VAL_82_id_SRSType        = 44;
static const long asn_VAL_82_reject            = 0;
static const long asn_VAL_82_mandatory         = 2;
static const long asn_VAL_83_id_ActivationTime = 45;
static const long asn_VAL_83_ignore            = 1;
static const long asn_VAL_83_optional          = 0;
static const asn_ioc_cell_t asn_IOS_PositioningActivationRequestIEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_82_id_SRSType},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_82_reject},
    {"&Value", aioc__type, &asn_DEF_SRSType},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_82_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_83_id_ActivationTime},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_83_ignore},
    {"&Value", aioc__type, &asn_DEF_ActivationTime},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_83_optional}};
static const asn_ioc_set_t asn_IOS_PositioningActivationRequestIEs_1[] = {
    {2, 4, asn_IOS_PositioningActivationRequestIEs_1_rows}};
static const long asn_VAL_84_id_CriticalityDiagnostics = 1;
static const long asn_VAL_84_ignore                    = 1;
static const long asn_VAL_84_optional                  = 0;
static const long asn_VAL_85_id_SystemFrameNumber      = 49;
static const long asn_VAL_85_ignore                    = 1;
static const long asn_VAL_85_optional                  = 0;
static const long asn_VAL_86_id_SlotNumber             = 50;
static const long asn_VAL_86_ignore                    = 1;
static const long asn_VAL_86_optional                  = 0;
static const asn_ioc_cell_t asn_IOS_PositioningActivationResponseIEs_1_rows[] =
    {{"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_84_id_CriticalityDiagnostics},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_84_ignore},
     {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_84_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
      &asn_VAL_85_id_SystemFrameNumber},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_85_ignore},
     {"&Value", aioc__type, &asn_DEF_SystemFrameNumber},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_85_optional},
     {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_86_id_SlotNumber},
     {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_86_ignore},
     {"&Value", aioc__type, &asn_DEF_SlotNumber},
     {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_86_optional}};
static const asn_ioc_set_t asn_IOS_PositioningActivationResponseIEs_1[] = {
    {3, 4, asn_IOS_PositioningActivationResponseIEs_1_rows}};
static const long asn_VAL_87_id_Cause                  = 0;
static const long asn_VAL_87_ignore                    = 1;
static const long asn_VAL_87_mandatory                 = 2;
static const long asn_VAL_88_id_CriticalityDiagnostics = 1;
static const long asn_VAL_88_ignore                    = 1;
static const long asn_VAL_88_optional                  = 0;
static const asn_ioc_cell_t asn_IOS_PositioningActivationFailureIEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID, &asn_VAL_87_id_Cause},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_87_ignore},
    {"&Value", aioc__type, &asn_DEF_Cause},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_87_mandatory},
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_88_id_CriticalityDiagnostics},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_88_ignore},
    {"&Value", aioc__type, &asn_DEF_CriticalityDiagnostics},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_88_optional}};
static const asn_ioc_set_t asn_IOS_PositioningActivationFailureIEs_1[] = {
    {2, 4, asn_IOS_PositioningActivationFailureIEs_1_rows}};
static const long asn_VAL_89_id_AbortTransmission                       = 53;
static const long asn_VAL_89_ignore                                     = 1;
static const long asn_VAL_89_mandatory                                  = 2;
static const asn_ioc_cell_t asn_IOS_PositioningDeactivationIEs_1_rows[] = {
    {"&id", aioc__value, &asn_DEF_ProtocolIE_ID,
     &asn_VAL_89_id_AbortTransmission},
    {"&criticality", aioc__value, &asn_DEF_Criticality, &asn_VAL_89_ignore},
    {"&Value", aioc__type, &asn_DEF_AbortTransmission},
    {"&presence", aioc__value, &asn_DEF_Presence, &asn_VAL_89_mandatory}};
static const asn_ioc_set_t asn_IOS_PositioningDeactivationIEs_1[] = {
    {1, 4, asn_IOS_PositioningDeactivationIEs_1_rows}};
static int memb_id_constraint_1(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OTDOA_Information_TypeIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOA_Information_TypeIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOA_Information_TypeIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_1(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_OTDOA_Information_TypeIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOA_Information_TypeIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOA_Information_TypeIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_1(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_5(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_5(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_5(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_9(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_9(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_9(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_13(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_13(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_13(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_17(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_17(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_17(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_21(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_21(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_21(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_25(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_25(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_25(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_29(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_29(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_29(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_33(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_MeasurementQuantities_ItemIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementQuantities_ItemIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementQuantities_ItemIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_33(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_MeasurementQuantities_ItemIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementQuantities_ItemIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementQuantities_ItemIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_33(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_37(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_MeasuredResultsValue_ExtensionIE_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_MeasuredResultsValue_ExtensionIE_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasuredResultsValue_ExtensionIE, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_37(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_MeasuredResultsValue_ExtensionIE_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_MeasuredResultsValue_ExtensionIE_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasuredResultsValue_ExtensionIE, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_37(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_41(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_41(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_41(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_45(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OTDOACell_Information_Item_ExtensionIE_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_OTDOACell_Information_Item_ExtensionIE_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOACell_Information_Item_ExtensionIE, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_45(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_OTDOACell_Information_Item_ExtensionIE_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_OTDOACell_Information_Item_ExtensionIE_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOACell_Information_Item_ExtensionIE, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_45(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_49(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OtherRATMeasurementQuantities_ItemIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_OtherRATMeasurementQuantities_ItemIEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OtherRATMeasurementQuantities_ItemIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_49(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_OtherRATMeasurementQuantities_ItemIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_OtherRATMeasurementQuantities_ItemIEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OtherRATMeasurementQuantities_ItemIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_49(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_53(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OtherRATMeasuredResultsValue_ExtensionIE_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_OtherRATMeasuredResultsValue_ExtensionIE_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_53(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_OtherRATMeasuredResultsValue_ExtensionIE_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_OtherRATMeasuredResultsValue_ExtensionIE_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_53(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_57(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_57(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_57(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_61(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_61(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_61(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_65(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_65(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_65(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_69(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_69(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_69(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_73(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_73(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_73(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_77(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_77(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_77(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_81(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_81(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_81(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_85(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_85(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_85(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_89(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_89(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_89(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_93(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_93(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_93(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_97(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_97(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_97(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_101(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_101(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_101(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_105(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_105(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_105(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_109(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_109(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_109(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_113(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_113(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_113(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_117(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_117(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_117(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_121(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_121(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_121(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_125(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static int memb_criticality_constraint_125(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_value_constraint_125(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_129(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_WLANMeasurementQuantities_ItemIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_WLANMeasurementQuantities_ItemIEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct WLANMeasurementQuantities_ItemIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_129(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_WLANMeasurementQuantities_ItemIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_WLANMeasurementQuantities_ItemIEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct WLANMeasurementQuantities_ItemIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_129(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_133(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_E_CIDMeasurementInitiationRequest_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_E_CIDMeasurementInitiationRequest_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementInitiationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_133(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_E_CIDMeasurementInitiationRequest_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_E_CIDMeasurementInitiationRequest_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementInitiationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_133(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_137(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_E_CIDMeasurementInitiationResponse_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_E_CIDMeasurementInitiationResponse_IEs_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementInitiationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_137(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_E_CIDMeasurementInitiationResponse_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_E_CIDMeasurementInitiationResponse_IEs_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementInitiationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_137(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_141(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_E_CIDMeasurementInitiationFailure_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_E_CIDMeasurementInitiationFailure_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementInitiationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_141(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_E_CIDMeasurementInitiationFailure_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_E_CIDMeasurementInitiationFailure_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementInitiationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_141(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_145(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_E_CIDMeasurementFailureIndication_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_E_CIDMeasurementFailureIndication_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementFailureIndication_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_145(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_E_CIDMeasurementFailureIndication_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_E_CIDMeasurementFailureIndication_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementFailureIndication_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_145(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_149(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_E_CIDMeasurementReport_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_E_CIDMeasurementReport_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementReport_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_149(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_E_CIDMeasurementReport_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_E_CIDMeasurementReport_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementReport_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_149(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_153(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_E_CIDMeasurementTerminationCommand_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_E_CIDMeasurementTerminationCommand_IEs_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementTerminationCommand_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_153(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_E_CIDMeasurementTerminationCommand_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable =
      asn_IOS_E_CIDMeasurementTerminationCommand_IEs_1;
  size_t constraining_column = 0; /* &id */
  size_t for_column          = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct E_CIDMeasurementTerminationCommand_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_153(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_157(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OTDOAInformationRequest_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOAInformationRequest_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOAInformationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_157(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_OTDOAInformationRequest_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOAInformationRequest_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOAInformationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_157(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_161(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OTDOAInformationResponse_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOAInformationResponse_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOAInformationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_161(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_OTDOAInformationResponse_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOAInformationResponse_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOAInformationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_161(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_165(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_OTDOAInformationFailure_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOAInformationFailure_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOAInformationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_165(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_OTDOAInformationFailure_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_OTDOAInformationFailure_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct OTDOAInformationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_165(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_169(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_AssistanceInformationControl_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_AssistanceInformationControl_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct AssistanceInformationControl_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_169(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_AssistanceInformationControl_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_AssistanceInformationControl_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct AssistanceInformationControl_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_169(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_173(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_AssistanceInformationFeedback_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_AssistanceInformationFeedback_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct AssistanceInformationFeedback_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_173(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_AssistanceInformationFeedback_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_AssistanceInformationFeedback_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct AssistanceInformationFeedback_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_173(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_177(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t select_ErrorIndication_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_ErrorIndication_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct ErrorIndication_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_177(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_ErrorIndication_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_ErrorIndication_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct ErrorIndication_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_177(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_181(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningInformationRequest_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationRequest_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_181(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningInformationRequest_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationRequest_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_181(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_185(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningInformationResponse_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationResponse_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_185(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningInformationResponse_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationResponse_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_185(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_189(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningInformationFailure_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationFailure_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_189(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningInformationFailure_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationFailure_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_189(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_193(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningInformationUpdate_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationUpdate_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationUpdate_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_193(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningInformationUpdate_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningInformationUpdate_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningInformationUpdate_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_193(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_197(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_MeasurementRequest_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementRequest_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_197(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_MeasurementRequest_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementRequest_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_197(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_201(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_MeasurementResponse_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementResponse_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_201(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_MeasurementResponse_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementResponse_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_201(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_205(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_MeasurementFailure_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementFailure_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_205(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_MeasurementFailure_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementFailure_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_205(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_209(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t select_MeasurementReport_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementReport_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementReport_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_209(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_MeasurementReport_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementReport_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementReport_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_209(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_213(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t select_MeasurementUpdate_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementUpdate_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementUpdate_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_213(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_MeasurementUpdate_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementUpdate_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementUpdate_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_213(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_217(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t select_MeasurementAbort_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementAbort_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementAbort_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_217(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_MeasurementAbort_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_MeasurementAbort_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementAbort_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_217(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_221(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_MeasurementFailureIndication_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_MeasurementFailureIndication_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementFailureIndication_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_221(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_MeasurementFailureIndication_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_MeasurementFailureIndication_IEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct MeasurementFailureIndication_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_221(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_225(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_TRPInformationRequest_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_TRPInformationRequest_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct TRPInformationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_225(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_TRPInformationRequest_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_TRPInformationRequest_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct TRPInformationRequest_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_225(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_229(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_TRPInformationResponse_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_TRPInformationResponse_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct TRPInformationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_229(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_TRPInformationResponse_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_TRPInformationResponse_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct TRPInformationResponse_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_229(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_233(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_TRPInformationFailure_IEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_TRPInformationFailure_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct TRPInformationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_233(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_TRPInformationFailure_IEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_TRPInformationFailure_IEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct TRPInformationFailure_IEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_233(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_237(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningActivationRequestIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_PositioningActivationRequestIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningActivationRequestIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_237(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningActivationRequestIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_PositioningActivationRequestIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningActivationRequestIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_237(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_241(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningActivationResponseIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningActivationResponseIEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningActivationResponseIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_241(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningActivationResponseIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable = asn_IOS_PositioningActivationResponseIEs_1;
  size_t constraining_column  = 0; /* &id */
  size_t for_column           = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningActivationResponseIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_241(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_245(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningActivationFailureIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_PositioningActivationFailureIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningActivationFailureIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_245(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t
select_PositioningActivationFailureIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_PositioningActivationFailureIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningActivationFailureIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_245(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static int memb_id_constraint_249(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  long value;

  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  value = *(const long*) sptr;

  if ((value >= 0 && value <= 65535)) {
    /* Constraint check succeeded */
    return 0;
  } else {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: constraint failed (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }
}

static asn_type_selector_result_t
select_PositioningDeactivationIEs_criticality_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_PositioningDeactivationIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 1; /* &criticality */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningDeactivationIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_criticality_constraint_249(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_type_selector_result_t select_PositioningDeactivationIEs_value_type(
    const asn_TYPE_descriptor_t* parent_type, const void* parent_sptr) {
  asn_type_selector_result_t result = {0, 0};
  const asn_ioc_set_t* itable       = asn_IOS_PositioningDeactivationIEs_1;
  size_t constraining_column        = 0; /* &id */
  size_t for_column                 = 2; /* &Value */
  size_t row, presence_index = 0;
  const long* constraining_value =
      (const long*) ((const char*) parent_sptr + offsetof(struct PositioningDeactivationIEs, id));

  for (row = 0; row < itable->rows_count; row++) {
    const asn_ioc_cell_t* constraining_cell =
        &itable->rows[row * itable->columns_count + constraining_column];
    const asn_ioc_cell_t* type_cell =
        &itable->rows[row * itable->columns_count + for_column];

    if (type_cell->cell_kind == aioc__undefined) continue;

    presence_index++;
    if (constraining_cell->type_descriptor->op->compare_struct(
            constraining_cell->type_descriptor, constraining_value,
            constraining_cell->value_sptr) == 0) {
      result.type_descriptor = type_cell->type_descriptor;
      result.presence_index  = presence_index;
      break;
    }
  }

  return result;
}

static int memb_value_constraint_249(
    const asn_TYPE_descriptor_t* td, const void* sptr,
    asn_app_constraint_failed_f* ctfailcb, void* app_key) {
  if (!sptr) {
    ASN__CTFAIL(
        app_key, td, sptr, "%s: value not given (%s:%d)", td->name, __FILE__,
        __LINE__);
    return -1;
  }

  if (1 /* No applicable constraints whatsoever */) {
    /* Nothing is here. See below */
  }

  return td->encoding_constraints.general_constraints(
      td, sptr, ctfailcb, app_key);
}

static asn_per_constraints_t asn_PER_memb_id_constr_2 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_3 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_4 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_6 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_7 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_8 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_10 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_11 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_12 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_14 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_15 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_16 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_18 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_19 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_20 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_22 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_23 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_24 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_26 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_27 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_28 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_30 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_31 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_32 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_34 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_35 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_36 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_38 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_39 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_40 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_42 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_43 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_44 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_46 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_47 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_48 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_50 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_51 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_52 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_54 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_55 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_56 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_58 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_59 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_60 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_62 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_63 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_64 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_66 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_67 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_68 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_70 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_71 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_72 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_74 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_75 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_76 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_78 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_79 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_80 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_82 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_83 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_84 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_86 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_87 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_88 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_90 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_91 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_92 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_94 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_95 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_96 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_98 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_99 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_100 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_102 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_103 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_104 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_106 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_107 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_108 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_110 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_111 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_112 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_114 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_115 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_116 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_118 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_119 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_120 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_122 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_123 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_124 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_126 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_127 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_128 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_130 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_131 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_132 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_134 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_135 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_136 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_138 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_139 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_140 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_142 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_143 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_144 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_146 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_147 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_148 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_150 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_151 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_152 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_154 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_155 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_156 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_158 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_159 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_160 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_162 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_163 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_164 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_166 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_167 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_168 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_170 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_171 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_172 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_174 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_175 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_176 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_178 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_179 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_180 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_182 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_183 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_184 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_186 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_187 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_188 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_190 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_191 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_192 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_194 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_195 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_196 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_198 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_199 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_200 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_202 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_203 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_204 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_206 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_207 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_208 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_210 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_211 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_212 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_214 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_215 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_216 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_218 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_219 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_220 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_222 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_223 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_224 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_226 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_227 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_228 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_230 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_231 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_232 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_234 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_235 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_236 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_238 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_239 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_240 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_242 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_243 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_244 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_246 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_247 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_248 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_id_constr_250 CC_NOTUSED = {
    {APC_CONSTRAINED, 16, 16, 0, 65535} /* (0..65535) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_criticality_constr_251 CC_NOTUSED = {
    {APC_CONSTRAINED, 2, 2, 0, 2} /* (0..2) */,
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_per_constraints_t asn_PER_memb_value_constr_252 CC_NOTUSED = {
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    {APC_UNCONSTRAINED, -1, -1, 0, 0},
    0,
    0 /* No PER value map */
};
static asn_TYPE_member_t asn_MBR_value_4[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OTDOA_Information_TypeIEs__value,
         choice.OTDOA_Information_Type_Item),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_OTDOA_Information_Type_Item,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "OTDOA-Information-Type-Item"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_4[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* OTDOA-Information-Type-Item */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_4 = {
    sizeof(struct OTDOA_Information_TypeIEs__value),
    offsetof(struct OTDOA_Information_TypeIEs__value, _asn_ctx),
    offsetof(struct OTDOA_Information_TypeIEs__value, present),
    sizeof(((struct OTDOA_Information_TypeIEs__value*) 0)->present),
    asn_MAP_value_tag2el_4,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_4 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_4,
        1,                     /* Elements count */
        &asn_SPC_value_specs_4 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OTDOA_Information_TypeIEs_1[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOA_Information_TypeIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_2, memb_id_constraint_1},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOA_Information_TypeIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OTDOA_Information_TypeIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_3, memb_criticality_constraint_1},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OTDOA_Information_TypeIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_4,
     select_OTDOA_Information_TypeIEs_value_type,
     {0, &asn_PER_memb_value_constr_4, memb_value_constraint_1},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_OTDOA_Information_TypeIEs_tags_1[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OTDOA_Information_TypeIEs_tag2el_1[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_OTDOA_Information_TypeIEs_specs_1 = {
    sizeof(struct OTDOA_Information_TypeIEs),
    offsetof(struct OTDOA_Information_TypeIEs, _asn_ctx),
    asn_MAP_OTDOA_Information_TypeIEs_tag2el_1,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OTDOA_Information_TypeIEs = {
    "OTDOA-Information-TypeIEs",
    "OTDOA-Information-TypeIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_OTDOA_Information_TypeIEs_tags_1,
    sizeof(asn_DEF_OTDOA_Information_TypeIEs_tags_1) /
        sizeof(asn_DEF_OTDOA_Information_TypeIEs_tags_1[0]), /* 1 */
    asn_DEF_OTDOA_Information_TypeIEs_tags_1,                /* Same as above */
    sizeof(asn_DEF_OTDOA_Information_TypeIEs_tags_1) /
        sizeof(asn_DEF_OTDOA_Information_TypeIEs_tags_1[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OTDOA_Information_TypeIEs_1,
    3,                                         /* Elements count */
    &asn_SPC_OTDOA_Information_TypeIEs_specs_1 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_8 = {
    sizeof(struct SRSType_ExtIEs__value),
    offsetof(struct SRSType_ExtIEs__value, _asn_ctx),
    offsetof(struct SRSType_ExtIEs__value, present),
    sizeof(((struct SRSType_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_8 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                     /* No members */
        &asn_SPC_value_specs_8 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_SRSType_ExtIEs_5[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct SRSType_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_6, memb_id_constraint_5},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct SRSType_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_7, memb_criticality_constraint_5},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct SRSType_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_8,
     0,
     {0, &asn_PER_memb_value_constr_8, memb_value_constraint_5},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_SRSType_ExtIEs_tags_5[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_SRSType_ExtIEs_tag2el_5[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_SRSType_ExtIEs_specs_5 = {
    sizeof(struct SRSType_ExtIEs),
    offsetof(struct SRSType_ExtIEs, _asn_ctx),
    asn_MAP_SRSType_ExtIEs_tag2el_5,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_SRSType_ExtIEs = {
    "SRSType-ExtIEs",
    "SRSType-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_SRSType_ExtIEs_tags_5,
    sizeof(asn_DEF_SRSType_ExtIEs_tags_5) /
        sizeof(asn_DEF_SRSType_ExtIEs_tags_5[0]), /* 1 */
    asn_DEF_SRSType_ExtIEs_tags_5,                /* Same as above */
    sizeof(asn_DEF_SRSType_ExtIEs_tags_5) /
        sizeof(asn_DEF_SRSType_ExtIEs_tags_5[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_SRSType_ExtIEs_5,
    3,                              /* Elements count */
    &asn_SPC_SRSType_ExtIEs_specs_5 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_12 = {
    sizeof(struct AbortTransmission_ExtIEs__value),
    offsetof(struct AbortTransmission_ExtIEs__value, _asn_ctx),
    offsetof(struct AbortTransmission_ExtIEs__value, present),
    sizeof(((struct AbortTransmission_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_12 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_12 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_AbortTransmission_ExtIEs_9[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct AbortTransmission_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_10, memb_id_constraint_9},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct AbortTransmission_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_11, memb_criticality_constraint_9},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct AbortTransmission_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_12,
     0,
     {0, &asn_PER_memb_value_constr_12, memb_value_constraint_9},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_AbortTransmission_ExtIEs_tags_9[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_AbortTransmission_ExtIEs_tag2el_9[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_AbortTransmission_ExtIEs_specs_9 = {
    sizeof(struct AbortTransmission_ExtIEs),
    offsetof(struct AbortTransmission_ExtIEs, _asn_ctx),
    asn_MAP_AbortTransmission_ExtIEs_tag2el_9,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_AbortTransmission_ExtIEs = {
    "AbortTransmission-ExtIEs",
    "AbortTransmission-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_AbortTransmission_ExtIEs_tags_9,
    sizeof(asn_DEF_AbortTransmission_ExtIEs_tags_9) /
        sizeof(asn_DEF_AbortTransmission_ExtIEs_tags_9[0]), /* 1 */
    asn_DEF_AbortTransmission_ExtIEs_tags_9,                /* Same as above */
    sizeof(asn_DEF_AbortTransmission_ExtIEs_tags_9) /
        sizeof(asn_DEF_AbortTransmission_ExtIEs_tags_9[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_AbortTransmission_ExtIEs_9,
    3,                                        /* Elements count */
    &asn_SPC_AbortTransmission_ExtIEs_specs_9 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_16 = {
    sizeof(struct Cause_ExtensionIE__value),
    offsetof(struct Cause_ExtensionIE__value, _asn_ctx),
    offsetof(struct Cause_ExtensionIE__value, present),
    sizeof(((struct Cause_ExtensionIE__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_16 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_16 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_Cause_ExtensionIE_13[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct Cause_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_14, memb_id_constraint_13},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct Cause_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_15, memb_criticality_constraint_13},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct Cause_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_16,
     0,
     {0, &asn_PER_memb_value_constr_16, memb_value_constraint_13},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_Cause_ExtensionIE_tags_13[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_Cause_ExtensionIE_tag2el_13[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_Cause_ExtensionIE_specs_13 = {
    sizeof(struct Cause_ExtensionIE),
    offsetof(struct Cause_ExtensionIE, _asn_ctx),
    asn_MAP_Cause_ExtensionIE_tag2el_13,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_Cause_ExtensionIE = {
    "Cause-ExtensionIE",
    "Cause-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_Cause_ExtensionIE_tags_13,
    sizeof(asn_DEF_Cause_ExtensionIE_tags_13) /
        sizeof(asn_DEF_Cause_ExtensionIE_tags_13[0]), /* 1 */
    asn_DEF_Cause_ExtensionIE_tags_13,                /* Same as above */
    sizeof(asn_DEF_Cause_ExtensionIE_tags_13) /
        sizeof(asn_DEF_Cause_ExtensionIE_tags_13[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_Cause_ExtensionIE_13,
    3,                                  /* Elements count */
    &asn_SPC_Cause_ExtensionIE_specs_13 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_20 = {
    sizeof(struct DL_PRSMutingPattern_ExtIEs__value),
    offsetof(struct DL_PRSMutingPattern_ExtIEs__value, _asn_ctx),
    offsetof(struct DL_PRSMutingPattern_ExtIEs__value, present),
    sizeof(((struct DL_PRSMutingPattern_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_20 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_20 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_DL_PRSMutingPattern_ExtIEs_17[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSMutingPattern_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_18, memb_id_constraint_17},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSMutingPattern_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_19, memb_criticality_constraint_17},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSMutingPattern_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_20,
     0,
     {0, &asn_PER_memb_value_constr_20, memb_value_constraint_17},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_DL_PRSMutingPattern_ExtIEs_tag2el_17[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_DL_PRSMutingPattern_ExtIEs_specs_17 = {
    sizeof(struct DL_PRSMutingPattern_ExtIEs),
    offsetof(struct DL_PRSMutingPattern_ExtIEs, _asn_ctx),
    asn_MAP_DL_PRSMutingPattern_ExtIEs_tag2el_17,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_DL_PRSMutingPattern_ExtIEs = {
    "DL-PRSMutingPattern-ExtIEs",
    "DL-PRSMutingPattern-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17,
    sizeof(asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17) /
        sizeof(asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17[0]), /* 1 */
    asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17, /* Same as above */
    sizeof(asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17) /
        sizeof(asn_DEF_DL_PRSMutingPattern_ExtIEs_tags_17[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_DL_PRSMutingPattern_ExtIEs_17,
    3,                                           /* Elements count */
    &asn_SPC_DL_PRSMutingPattern_ExtIEs_specs_17 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_24 = {
    sizeof(struct DL_PRSResourceSetARPLocation_ExtIEs__value),
    offsetof(struct DL_PRSResourceSetARPLocation_ExtIEs__value, _asn_ctx),
    offsetof(struct DL_PRSResourceSetARPLocation_ExtIEs__value, present),
    sizeof(((struct DL_PRSResourceSetARPLocation_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_24 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_24 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_DL_PRSResourceSetARPLocation_ExtIEs_21[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSResourceSetARPLocation_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_22, memb_id_constraint_21},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSResourceSetARPLocation_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_23, memb_criticality_constraint_21},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSResourceSetARPLocation_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_24,
     0,
     {0, &asn_PER_memb_value_constr_24, memb_value_constraint_21},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_DL_PRSResourceSetARPLocation_ExtIEs_tag2el_21[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_DL_PRSResourceSetARPLocation_ExtIEs_specs_21 =
    {
        sizeof(struct DL_PRSResourceSetARPLocation_ExtIEs),
        offsetof(struct DL_PRSResourceSetARPLocation_ExtIEs, _asn_ctx),
        asn_MAP_DL_PRSResourceSetARPLocation_ExtIEs_tag2el_21,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs = {
    "DL-PRSResourceSetARPLocation-ExtIEs",
    "DL-PRSResourceSetARPLocation-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21,
    sizeof(asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21) /
        sizeof(asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21[0]), /* 1 */
    asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21, /* Same as above */
    sizeof(asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21) /
        sizeof(asn_DEF_DL_PRSResourceSetARPLocation_ExtIEs_tags_21[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_DL_PRSResourceSetARPLocation_ExtIEs_21,
    3,                                                    /* Elements count */
    &asn_SPC_DL_PRSResourceSetARPLocation_ExtIEs_specs_21 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_28 = {
    sizeof(struct DL_PRSResourceARPLocation_ExtIEs__value),
    offsetof(struct DL_PRSResourceARPLocation_ExtIEs__value, _asn_ctx),
    offsetof(struct DL_PRSResourceARPLocation_ExtIEs__value, present),
    sizeof(((struct DL_PRSResourceARPLocation_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_28 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_28 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_DL_PRSResourceARPLocation_ExtIEs_25[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSResourceARPLocation_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_26, memb_id_constraint_25},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSResourceARPLocation_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_27, memb_criticality_constraint_25},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct DL_PRSResourceARPLocation_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_28,
     0,
     {0, &asn_PER_memb_value_constr_28, memb_value_constraint_25},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_DL_PRSResourceARPLocation_ExtIEs_tag2el_25[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_DL_PRSResourceARPLocation_ExtIEs_specs_25 = {
    sizeof(struct DL_PRSResourceARPLocation_ExtIEs),
    offsetof(struct DL_PRSResourceARPLocation_ExtIEs, _asn_ctx),
    asn_MAP_DL_PRSResourceARPLocation_ExtIEs_tag2el_25,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_DL_PRSResourceARPLocation_ExtIEs = {
    "DL-PRSResourceARPLocation-ExtIEs",
    "DL-PRSResourceARPLocation-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25,
    sizeof(asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25) /
        sizeof(asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25[0]), /* 1 */
    asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25, /* Same as above */
    sizeof(asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25) /
        sizeof(asn_DEF_DL_PRSResourceARPLocation_ExtIEs_tags_25[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_DL_PRSResourceARPLocation_ExtIEs_25,
    3,                                                 /* Elements count */
    &asn_SPC_DL_PRSResourceARPLocation_ExtIEs_specs_25 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_32 = {
    sizeof(struct GNBRxTxTimeDiffMeas_ExtIEs__value),
    offsetof(struct GNBRxTxTimeDiffMeas_ExtIEs__value, _asn_ctx),
    offsetof(struct GNBRxTxTimeDiffMeas_ExtIEs__value, present),
    sizeof(((struct GNBRxTxTimeDiffMeas_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_32 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_32 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_GNBRxTxTimeDiffMeas_ExtIEs_29[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct GNBRxTxTimeDiffMeas_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_30, memb_id_constraint_29},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct GNBRxTxTimeDiffMeas_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_31, memb_criticality_constraint_29},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct GNBRxTxTimeDiffMeas_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_32,
     0,
     {0, &asn_PER_memb_value_constr_32, memb_value_constraint_29},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_GNBRxTxTimeDiffMeas_ExtIEs_tag2el_29[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_GNBRxTxTimeDiffMeas_ExtIEs_specs_29 = {
    sizeof(struct GNBRxTxTimeDiffMeas_ExtIEs),
    offsetof(struct GNBRxTxTimeDiffMeas_ExtIEs, _asn_ctx),
    asn_MAP_GNBRxTxTimeDiffMeas_ExtIEs_tag2el_29,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs = {
    "GNBRxTxTimeDiffMeas-ExtIEs",
    "GNBRxTxTimeDiffMeas-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29,
    sizeof(asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29) /
        sizeof(asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29[0]), /* 1 */
    asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29, /* Same as above */
    sizeof(asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29) /
        sizeof(asn_DEF_GNBRxTxTimeDiffMeas_ExtIEs_tags_29[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_GNBRxTxTimeDiffMeas_ExtIEs_29,
    3,                                           /* Elements count */
    &asn_SPC_GNBRxTxTimeDiffMeas_ExtIEs_specs_29 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_36[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementQuantities_ItemIEs__value,
         choice.MeasurementQuantities_Item),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_MeasurementQuantities_Item,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "MeasurementQuantities-Item"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_36[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* MeasurementQuantities-Item */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_36 = {
    sizeof(struct MeasurementQuantities_ItemIEs__value),
    offsetof(struct MeasurementQuantities_ItemIEs__value, _asn_ctx),
    offsetof(struct MeasurementQuantities_ItemIEs__value, present),
    sizeof(((struct MeasurementQuantities_ItemIEs__value*) 0)->present),
    asn_MAP_value_tag2el_36,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_36 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_36,
        1,                      /* Elements count */
        &asn_SPC_value_specs_36 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementQuantities_ItemIEs_33[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementQuantities_ItemIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_34, memb_id_constraint_33},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementQuantities_ItemIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementQuantities_ItemIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_35, memb_criticality_constraint_33},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementQuantities_ItemIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_36,
     select_MeasurementQuantities_ItemIEs_value_type,
     {0, &asn_PER_memb_value_constr_36, memb_value_constraint_33},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementQuantities_ItemIEs_tags_33[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_MeasurementQuantities_ItemIEs_tag2el_33[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementQuantities_ItemIEs_specs_33 = {
    sizeof(struct MeasurementQuantities_ItemIEs),
    offsetof(struct MeasurementQuantities_ItemIEs, _asn_ctx),
    asn_MAP_MeasurementQuantities_ItemIEs_tag2el_33,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementQuantities_ItemIEs = {
    "MeasurementQuantities-ItemIEs",
    "MeasurementQuantities-ItemIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementQuantities_ItemIEs_tags_33,
    sizeof(asn_DEF_MeasurementQuantities_ItemIEs_tags_33) /
        sizeof(asn_DEF_MeasurementQuantities_ItemIEs_tags_33[0]), /* 1 */
    asn_DEF_MeasurementQuantities_ItemIEs_tags_33, /* Same as above */
    sizeof(asn_DEF_MeasurementQuantities_ItemIEs_tags_33) /
        sizeof(asn_DEF_MeasurementQuantities_ItemIEs_tags_33[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementQuantities_ItemIEs_33,
    3,                                              /* Elements count */
    &asn_SPC_MeasurementQuantities_ItemIEs_specs_33 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_40[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasuredResultsValue_ExtensionIE__value, choice.ResultSS_RSRP),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_ResultSS_RSRP,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ResultSS-RSRP"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasuredResultsValue_ExtensionIE__value, choice.ResultSS_RSRQ),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_ResultSS_RSRQ,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ResultSS-RSRQ"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasuredResultsValue_ExtensionIE__value, choice.ResultCSI_RSRP),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_ResultCSI_RSRP,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ResultCSI-RSRP"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasuredResultsValue_ExtensionIE__value, choice.ResultCSI_RSRQ),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_ResultCSI_RSRQ,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ResultCSI-RSRQ"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasuredResultsValue_ExtensionIE__value, choice.UL_AoA),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_UL_AoA,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UL-AoA"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_40[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 4},  /* ResultSS-RSRP */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1, 3}, /* ResultSS-RSRQ */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, -2, 2}, /* ResultCSI-RSRP */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 3, -3, 1}, /* ResultCSI-RSRQ */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 4, -4, 0}  /* UL-AoA */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_40 = {
    sizeof(struct MeasuredResultsValue_ExtensionIE__value),
    offsetof(struct MeasuredResultsValue_ExtensionIE__value, _asn_ctx),
    offsetof(struct MeasuredResultsValue_ExtensionIE__value, present),
    sizeof(((struct MeasuredResultsValue_ExtensionIE__value*) 0)->present),
    asn_MAP_value_tag2el_40,
    5, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_40 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_40,
        5,                      /* Elements count */
        &asn_SPC_value_specs_40 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasuredResultsValue_ExtensionIE_37[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasuredResultsValue_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_38, memb_id_constraint_37},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasuredResultsValue_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasuredResultsValue_ExtensionIE_criticality_type,
     {0, &asn_PER_memb_criticality_constr_39, memb_criticality_constraint_37},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasuredResultsValue_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_40,
     select_MeasuredResultsValue_ExtensionIE_value_type,
     {0, &asn_PER_memb_value_constr_40, memb_value_constraint_37},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_MeasuredResultsValue_ExtensionIE_tag2el_37[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasuredResultsValue_ExtensionIE_specs_37 = {
    sizeof(struct MeasuredResultsValue_ExtensionIE),
    offsetof(struct MeasuredResultsValue_ExtensionIE, _asn_ctx),
    asn_MAP_MeasuredResultsValue_ExtensionIE_tag2el_37,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasuredResultsValue_ExtensionIE = {
    "MeasuredResultsValue-ExtensionIE",
    "MeasuredResultsValue-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37,
    sizeof(asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37) /
        sizeof(asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37[0]), /* 1 */
    asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37, /* Same as above */
    sizeof(asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37) /
        sizeof(asn_DEF_MeasuredResultsValue_ExtensionIE_tags_37[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasuredResultsValue_ExtensionIE_37,
    3,                                                 /* Elements count */
    &asn_SPC_MeasuredResultsValue_ExtensionIE_specs_37 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_44 = {
    sizeof(struct NG_RANCell_ExtensionIE__value),
    offsetof(struct NG_RANCell_ExtensionIE__value, _asn_ctx),
    offsetof(struct NG_RANCell_ExtensionIE__value, present),
    sizeof(((struct NG_RANCell_ExtensionIE__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_44 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_44 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_NG_RANCell_ExtensionIE_41[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct NG_RANCell_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_42, memb_id_constraint_41},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct NG_RANCell_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_43, memb_criticality_constraint_41},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct NG_RANCell_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_44,
     0,
     {0, &asn_PER_memb_value_constr_44, memb_value_constraint_41},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_NG_RANCell_ExtensionIE_tags_41[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_NG_RANCell_ExtensionIE_tag2el_41[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_NG_RANCell_ExtensionIE_specs_41 = {
    sizeof(struct NG_RANCell_ExtensionIE),
    offsetof(struct NG_RANCell_ExtensionIE, _asn_ctx),
    asn_MAP_NG_RANCell_ExtensionIE_tag2el_41,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_NG_RANCell_ExtensionIE = {
    "NG-RANCell-ExtensionIE",
    "NG-RANCell-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_NG_RANCell_ExtensionIE_tags_41,
    sizeof(asn_DEF_NG_RANCell_ExtensionIE_tags_41) /
        sizeof(asn_DEF_NG_RANCell_ExtensionIE_tags_41[0]), /* 1 */
    asn_DEF_NG_RANCell_ExtensionIE_tags_41,                /* Same as above */
    sizeof(asn_DEF_NG_RANCell_ExtensionIE_tags_41) /
        sizeof(asn_DEF_NG_RANCell_ExtensionIE_tags_41[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_NG_RANCell_ExtensionIE_41,
    3,                                       /* Elements count */
    &asn_SPC_NG_RANCell_ExtensionIE_specs_41 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_48[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OTDOACell_Information_Item_ExtensionIE__value,
         choice.TDD_Config_EUTRA_Item),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TDD_Config_EUTRA_Item,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TDD-Config-EUTRA-Item"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_48[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 0} /* TDD-Config-EUTRA-Item */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_48 = {
    sizeof(struct OTDOACell_Information_Item_ExtensionIE__value),
    offsetof(struct OTDOACell_Information_Item_ExtensionIE__value, _asn_ctx),
    offsetof(struct OTDOACell_Information_Item_ExtensionIE__value, present),
    sizeof(
        ((struct OTDOACell_Information_Item_ExtensionIE__value*) 0)->present),
    asn_MAP_value_tag2el_48,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_48 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_48,
        1,                      /* Elements count */
        &asn_SPC_value_specs_48 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OTDOACell_Information_Item_ExtensionIE_45[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOACell_Information_Item_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_46, memb_id_constraint_45},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOACell_Information_Item_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OTDOACell_Information_Item_ExtensionIE_criticality_type,
     {0, &asn_PER_memb_criticality_constr_47, memb_criticality_constraint_45},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OTDOACell_Information_Item_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_48,
     select_OTDOACell_Information_Item_ExtensionIE_value_type,
     {0, &asn_PER_memb_value_constr_48, memb_value_constraint_45},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OTDOACell_Information_Item_ExtensionIE_tag2el_45[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_OTDOACell_Information_Item_ExtensionIE_specs_45 = {
        sizeof(struct OTDOACell_Information_Item_ExtensionIE),
        offsetof(struct OTDOACell_Information_Item_ExtensionIE, _asn_ctx),
        asn_MAP_OTDOACell_Information_Item_ExtensionIE_tag2el_45,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OTDOACell_Information_Item_ExtensionIE = {
    "OTDOACell-Information-Item-ExtensionIE",
    "OTDOACell-Information-Item-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45,
    sizeof(asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45) /
        sizeof(
            asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45[0]), /* 1 */
    asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45, /* Same as above */
    sizeof(asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45) /
        sizeof(
            asn_DEF_OTDOACell_Information_Item_ExtensionIE_tags_45[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OTDOACell_Information_Item_ExtensionIE_45,
    3, /* Elements count */
    &asn_SPC_OTDOACell_Information_Item_ExtensionIE_specs_45 /* Additional specs
                                                              */
};

static asn_TYPE_member_t asn_MBR_value_52[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OtherRATMeasurementQuantities_ItemIEs__value,
         choice.OtherRATMeasurementQuantities_Item),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_OtherRATMeasurementQuantities_Item,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "OtherRATMeasurementQuantities-Item"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_52[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* OtherRATMeasurementQuantities-Item */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_52 = {
    sizeof(struct OtherRATMeasurementQuantities_ItemIEs__value),
    offsetof(struct OtherRATMeasurementQuantities_ItemIEs__value, _asn_ctx),
    offsetof(struct OtherRATMeasurementQuantities_ItemIEs__value, present),
    sizeof(((struct OtherRATMeasurementQuantities_ItemIEs__value*) 0)->present),
    asn_MAP_value_tag2el_52,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_52 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_52,
        1,                      /* Elements count */
        &asn_SPC_value_specs_52 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OtherRATMeasurementQuantities_ItemIEs_49[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OtherRATMeasurementQuantities_ItemIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_50, memb_id_constraint_49},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OtherRATMeasurementQuantities_ItemIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OtherRATMeasurementQuantities_ItemIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_51, memb_criticality_constraint_49},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OtherRATMeasurementQuantities_ItemIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_52,
     select_OtherRATMeasurementQuantities_ItemIEs_value_type,
     {0, &asn_PER_memb_value_constr_52, memb_value_constraint_49},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OtherRATMeasurementQuantities_ItemIEs_tag2el_49[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_OtherRATMeasurementQuantities_ItemIEs_specs_49 = {
        sizeof(struct OtherRATMeasurementQuantities_ItemIEs),
        offsetof(struct OtherRATMeasurementQuantities_ItemIEs, _asn_ctx),
        asn_MAP_OtherRATMeasurementQuantities_ItemIEs_tag2el_49,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OtherRATMeasurementQuantities_ItemIEs = {
    "OtherRATMeasurementQuantities-ItemIEs",
    "OtherRATMeasurementQuantities-ItemIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49,
    sizeof(asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49) /
        sizeof(
            asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49[0]), /* 1 */
    asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49, /* Same as above */
    sizeof(asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49) /
        sizeof(
            asn_DEF_OtherRATMeasurementQuantities_ItemIEs_tags_49[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OtherRATMeasurementQuantities_ItemIEs_49,
    3,                                                      /* Elements count */
    &asn_SPC_OtherRATMeasurementQuantities_ItemIEs_specs_49 /* Additional specs
                                                             */
};

static asn_TYPE_member_t asn_MBR_value_56[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OtherRATMeasuredResultsValue_ExtensionIE__value,
         choice.ResultNR),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_ResultNR,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ResultNR"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OtherRATMeasuredResultsValue_ExtensionIE__value,
         choice.ResultEUTRA),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_ResultEUTRA,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ResultEUTRA"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_56[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 1}, /* ResultNR */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1, 0} /* ResultEUTRA */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_56 = {
    sizeof(struct OtherRATMeasuredResultsValue_ExtensionIE__value),
    offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE__value, _asn_ctx),
    offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE__value, present),
    sizeof(
        ((struct OtherRATMeasuredResultsValue_ExtensionIE__value*) 0)->present),
    asn_MAP_value_tag2el_56,
    2, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_56 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_56,
        2,                      /* Elements count */
        &asn_SPC_value_specs_56 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OtherRATMeasuredResultsValue_ExtensionIE_53[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_54, memb_id_constraint_53},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OtherRATMeasuredResultsValue_ExtensionIE_criticality_type,
     {0, &asn_PER_memb_criticality_constr_55, memb_criticality_constraint_53},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_56,
     select_OtherRATMeasuredResultsValue_ExtensionIE_value_type,
     {0, &asn_PER_memb_value_constr_56, memb_value_constraint_53},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OtherRATMeasuredResultsValue_ExtensionIE_tag2el_53[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_OtherRATMeasuredResultsValue_ExtensionIE_specs_53 = {
        sizeof(struct OtherRATMeasuredResultsValue_ExtensionIE),
        offsetof(struct OtherRATMeasuredResultsValue_ExtensionIE, _asn_ctx),
        asn_MAP_OtherRATMeasuredResultsValue_ExtensionIE_tag2el_53,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE = {
    "OtherRATMeasuredResultsValue-ExtensionIE",
    "OtherRATMeasuredResultsValue-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53,
    sizeof(asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53) /
        sizeof(
            asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53[0]), /* 1
                                                                           */
    asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53, /* Same as above
                                                               */
    sizeof(asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53) /
        sizeof(
            asn_DEF_OtherRATMeasuredResultsValue_ExtensionIE_tags_53[0]), /* 1
                                                                           */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OtherRATMeasuredResultsValue_ExtensionIE_53,
    3, /* Elements count */
    &asn_SPC_OtherRATMeasuredResultsValue_ExtensionIE_specs_53 /* Additional
                                                                  specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_60 = {
    sizeof(struct PathlossReferenceSignal_ExtensionIE__value),
    offsetof(struct PathlossReferenceSignal_ExtensionIE__value, _asn_ctx),
    offsetof(struct PathlossReferenceSignal_ExtensionIE__value, present),
    sizeof(((struct PathlossReferenceSignal_ExtensionIE__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_60 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_60 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PathlossReferenceSignal_ExtensionIE_57[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PathlossReferenceSignal_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_58, memb_id_constraint_57},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PathlossReferenceSignal_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_59, memb_criticality_constraint_57},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PathlossReferenceSignal_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_60,
     0,
     {0, &asn_PER_memb_value_constr_60, memb_value_constraint_57},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PathlossReferenceSignal_ExtensionIE_tag2el_57[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PathlossReferenceSignal_ExtensionIE_specs_57 =
    {
        sizeof(struct PathlossReferenceSignal_ExtensionIE),
        offsetof(struct PathlossReferenceSignal_ExtensionIE, _asn_ctx),
        asn_MAP_PathlossReferenceSignal_ExtensionIE_tag2el_57,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PathlossReferenceSignal_ExtensionIE = {
    "PathlossReferenceSignal-ExtensionIE",
    "PathlossReferenceSignal-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57,
    sizeof(asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57) /
        sizeof(asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57[0]), /* 1 */
    asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57, /* Same as above */
    sizeof(asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57) /
        sizeof(asn_DEF_PathlossReferenceSignal_ExtensionIE_tags_57[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PathlossReferenceSignal_ExtensionIE_57,
    3,                                                    /* Elements count */
    &asn_SPC_PathlossReferenceSignal_ExtensionIE_specs_57 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_64 = {
    sizeof(struct PosResourceSetType_ExtIEs__value),
    offsetof(struct PosResourceSetType_ExtIEs__value, _asn_ctx),
    offsetof(struct PosResourceSetType_ExtIEs__value, present),
    sizeof(((struct PosResourceSetType_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_64 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_64 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PosResourceSetType_ExtIEs_61[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PosResourceSetType_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_62, memb_id_constraint_61},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PosResourceSetType_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_63, memb_criticality_constraint_61},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PosResourceSetType_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_64,
     0,
     {0, &asn_PER_memb_value_constr_64, memb_value_constraint_61},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_PosResourceSetType_ExtIEs_tags_61[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PosResourceSetType_ExtIEs_tag2el_61[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PosResourceSetType_ExtIEs_specs_61 = {
    sizeof(struct PosResourceSetType_ExtIEs),
    offsetof(struct PosResourceSetType_ExtIEs, _asn_ctx),
    asn_MAP_PosResourceSetType_ExtIEs_tag2el_61,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PosResourceSetType_ExtIEs = {
    "PosResourceSetType-ExtIEs",
    "PosResourceSetType-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PosResourceSetType_ExtIEs_tags_61,
    sizeof(asn_DEF_PosResourceSetType_ExtIEs_tags_61) /
        sizeof(asn_DEF_PosResourceSetType_ExtIEs_tags_61[0]), /* 1 */
    asn_DEF_PosResourceSetType_ExtIEs_tags_61, /* Same as above */
    sizeof(asn_DEF_PosResourceSetType_ExtIEs_tags_61) /
        sizeof(asn_DEF_PosResourceSetType_ExtIEs_tags_61[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PosResourceSetType_ExtIEs_61,
    3,                                          /* Elements count */
    &asn_SPC_PosResourceSetType_ExtIEs_specs_61 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_68 = {
    sizeof(struct PRSMutingConfiguration_EUTRA_ExtensionIE__value),
    offsetof(struct PRSMutingConfiguration_EUTRA_ExtensionIE__value, _asn_ctx),
    offsetof(struct PRSMutingConfiguration_EUTRA_ExtensionIE__value, present),
    sizeof(
        ((struct PRSMutingConfiguration_EUTRA_ExtensionIE__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_68 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_68 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PRSMutingConfiguration_EUTRA_ExtensionIE_65[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PRSMutingConfiguration_EUTRA_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_66, memb_id_constraint_65},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PRSMutingConfiguration_EUTRA_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_67, memb_criticality_constraint_65},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PRSMutingConfiguration_EUTRA_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_68,
     0,
     {0, &asn_PER_memb_value_constr_68, memb_value_constraint_65},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PRSMutingConfiguration_EUTRA_ExtensionIE_tag2el_65[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_PRSMutingConfiguration_EUTRA_ExtensionIE_specs_65 = {
        sizeof(struct PRSMutingConfiguration_EUTRA_ExtensionIE),
        offsetof(struct PRSMutingConfiguration_EUTRA_ExtensionIE, _asn_ctx),
        asn_MAP_PRSMutingConfiguration_EUTRA_ExtensionIE_tag2el_65,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE = {
    "PRSMutingConfiguration-EUTRA-ExtensionIE",
    "PRSMutingConfiguration-EUTRA-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65,
    sizeof(asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65) /
        sizeof(
            asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65[0]), /* 1
                                                                           */
    asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65, /* Same as above
                                                               */
    sizeof(asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65) /
        sizeof(
            asn_DEF_PRSMutingConfiguration_EUTRA_ExtensionIE_tags_65[0]), /* 1
                                                                           */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PRSMutingConfiguration_EUTRA_ExtensionIE_65,
    3, /* Elements count */
    &asn_SPC_PRSMutingConfiguration_EUTRA_ExtensionIE_specs_65 /* Additional
                                                                  specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_72 = {
    sizeof(struct ReferenceSignal_ExtensionIE__value),
    offsetof(struct ReferenceSignal_ExtensionIE__value, _asn_ctx),
    offsetof(struct ReferenceSignal_ExtensionIE__value, present),
    sizeof(((struct ReferenceSignal_ExtensionIE__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_72 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_72 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_ReferenceSignal_ExtensionIE_69[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ReferenceSignal_ExtensionIE, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_70, memb_id_constraint_69},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ReferenceSignal_ExtensionIE, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_71, memb_criticality_constraint_69},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct ReferenceSignal_ExtensionIE, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_72,
     0,
     {0, &asn_PER_memb_value_constr_72, memb_value_constraint_69},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_ReferenceSignal_ExtensionIE_tags_69[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_ReferenceSignal_ExtensionIE_tag2el_69[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_ReferenceSignal_ExtensionIE_specs_69 = {
    sizeof(struct ReferenceSignal_ExtensionIE),
    offsetof(struct ReferenceSignal_ExtensionIE, _asn_ctx),
    asn_MAP_ReferenceSignal_ExtensionIE_tag2el_69,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ReferenceSignal_ExtensionIE = {
    "ReferenceSignal-ExtensionIE",
    "ReferenceSignal-ExtensionIE",
    &asn_OP_SEQUENCE,
    asn_DEF_ReferenceSignal_ExtensionIE_tags_69,
    sizeof(asn_DEF_ReferenceSignal_ExtensionIE_tags_69) /
        sizeof(asn_DEF_ReferenceSignal_ExtensionIE_tags_69[0]), /* 1 */
    asn_DEF_ReferenceSignal_ExtensionIE_tags_69, /* Same as above */
    sizeof(asn_DEF_ReferenceSignal_ExtensionIE_tags_69) /
        sizeof(asn_DEF_ReferenceSignal_ExtensionIE_tags_69[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_ReferenceSignal_ExtensionIE_69,
    3,                                            /* Elements count */
    &asn_SPC_ReferenceSignal_ExtensionIE_specs_69 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_76 = {
    sizeof(struct ReferencePoint_ExtIEs__value),
    offsetof(struct ReferencePoint_ExtIEs__value, _asn_ctx),
    offsetof(struct ReferencePoint_ExtIEs__value, present),
    sizeof(((struct ReferencePoint_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_76 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_76 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_ReferencePoint_ExtIEs_73[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ReferencePoint_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_74, memb_id_constraint_73},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ReferencePoint_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_75, memb_criticality_constraint_73},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct ReferencePoint_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_76,
     0,
     {0, &asn_PER_memb_value_constr_76, memb_value_constraint_73},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_ReferencePoint_ExtIEs_tags_73[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_ReferencePoint_ExtIEs_tag2el_73[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_ReferencePoint_ExtIEs_specs_73 = {
    sizeof(struct ReferencePoint_ExtIEs),
    offsetof(struct ReferencePoint_ExtIEs, _asn_ctx),
    asn_MAP_ReferencePoint_ExtIEs_tag2el_73,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ReferencePoint_ExtIEs = {
    "ReferencePoint-ExtIEs",
    "ReferencePoint-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_ReferencePoint_ExtIEs_tags_73,
    sizeof(asn_DEF_ReferencePoint_ExtIEs_tags_73) /
        sizeof(asn_DEF_ReferencePoint_ExtIEs_tags_73[0]), /* 1 */
    asn_DEF_ReferencePoint_ExtIEs_tags_73,                /* Same as above */
    sizeof(asn_DEF_ReferencePoint_ExtIEs_tags_73) /
        sizeof(asn_DEF_ReferencePoint_ExtIEs_tags_73[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_ReferencePoint_ExtIEs_73,
    3,                                      /* Elements count */
    &asn_SPC_ReferencePoint_ExtIEs_specs_73 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_80 = {
    sizeof(struct ResourceSetType_ExtIEs__value),
    offsetof(struct ResourceSetType_ExtIEs__value, _asn_ctx),
    offsetof(struct ResourceSetType_ExtIEs__value, present),
    sizeof(((struct ResourceSetType_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_80 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_80 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_ResourceSetType_ExtIEs_77[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ResourceSetType_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_78, memb_id_constraint_77},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ResourceSetType_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_79, memb_criticality_constraint_77},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct ResourceSetType_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_80,
     0,
     {0, &asn_PER_memb_value_constr_80, memb_value_constraint_77},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_ResourceSetType_ExtIEs_tags_77[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_ResourceSetType_ExtIEs_tag2el_77[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_ResourceSetType_ExtIEs_specs_77 = {
    sizeof(struct ResourceSetType_ExtIEs),
    offsetof(struct ResourceSetType_ExtIEs, _asn_ctx),
    asn_MAP_ResourceSetType_ExtIEs_tag2el_77,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ResourceSetType_ExtIEs = {
    "ResourceSetType-ExtIEs",
    "ResourceSetType-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_ResourceSetType_ExtIEs_tags_77,
    sizeof(asn_DEF_ResourceSetType_ExtIEs_tags_77) /
        sizeof(asn_DEF_ResourceSetType_ExtIEs_tags_77[0]), /* 1 */
    asn_DEF_ResourceSetType_ExtIEs_tags_77,                /* Same as above */
    sizeof(asn_DEF_ResourceSetType_ExtIEs_tags_77) /
        sizeof(asn_DEF_ResourceSetType_ExtIEs_tags_77[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_ResourceSetType_ExtIEs_77,
    3,                                       /* Elements count */
    &asn_SPC_ResourceSetType_ExtIEs_specs_77 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_84 = {
    sizeof(struct ResourceType_ExtIEs__value),
    offsetof(struct ResourceType_ExtIEs__value, _asn_ctx),
    offsetof(struct ResourceType_ExtIEs__value, present),
    sizeof(((struct ResourceType_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_84 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_84 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_ResourceType_ExtIEs_81[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ResourceType_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_82, memb_id_constraint_81},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ResourceType_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_83, memb_criticality_constraint_81},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct ResourceType_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_84,
     0,
     {0, &asn_PER_memb_value_constr_84, memb_value_constraint_81},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_ResourceType_ExtIEs_tags_81[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_ResourceType_ExtIEs_tag2el_81[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_ResourceType_ExtIEs_specs_81 = {
    sizeof(struct ResourceType_ExtIEs),
    offsetof(struct ResourceType_ExtIEs, _asn_ctx),
    asn_MAP_ResourceType_ExtIEs_tag2el_81,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ResourceType_ExtIEs = {
    "ResourceType-ExtIEs",
    "ResourceType-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_ResourceType_ExtIEs_tags_81,
    sizeof(asn_DEF_ResourceType_ExtIEs_tags_81) /
        sizeof(asn_DEF_ResourceType_ExtIEs_tags_81[0]), /* 1 */
    asn_DEF_ResourceType_ExtIEs_tags_81,                /* Same as above */
    sizeof(asn_DEF_ResourceType_ExtIEs_tags_81) /
        sizeof(asn_DEF_ResourceType_ExtIEs_tags_81[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_ResourceType_ExtIEs_81,
    3,                                    /* Elements count */
    &asn_SPC_ResourceType_ExtIEs_specs_81 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_88 = {
    sizeof(struct ResourceTypePos_ExtIEs__value),
    offsetof(struct ResourceTypePos_ExtIEs__value, _asn_ctx),
    offsetof(struct ResourceTypePos_ExtIEs__value, present),
    sizeof(((struct ResourceTypePos_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_88 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_88 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_ResourceTypePos_ExtIEs_85[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ResourceTypePos_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_86, memb_id_constraint_85},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ResourceTypePos_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_87, memb_criticality_constraint_85},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct ResourceTypePos_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_88,
     0,
     {0, &asn_PER_memb_value_constr_88, memb_value_constraint_85},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_ResourceTypePos_ExtIEs_tags_85[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_ResourceTypePos_ExtIEs_tag2el_85[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_ResourceTypePos_ExtIEs_specs_85 = {
    sizeof(struct ResourceTypePos_ExtIEs),
    offsetof(struct ResourceTypePos_ExtIEs, _asn_ctx),
    asn_MAP_ResourceTypePos_ExtIEs_tag2el_85,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ResourceTypePos_ExtIEs = {
    "ResourceTypePos-ExtIEs",
    "ResourceTypePos-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_ResourceTypePos_ExtIEs_tags_85,
    sizeof(asn_DEF_ResourceTypePos_ExtIEs_tags_85) /
        sizeof(asn_DEF_ResourceTypePos_ExtIEs_tags_85[0]), /* 1 */
    asn_DEF_ResourceTypePos_ExtIEs_tags_85,                /* Same as above */
    sizeof(asn_DEF_ResourceTypePos_ExtIEs_tags_85) /
        sizeof(asn_DEF_ResourceTypePos_ExtIEs_tags_85[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_ResourceTypePos_ExtIEs_85,
    3,                                       /* Elements count */
    &asn_SPC_ResourceTypePos_ExtIEs_specs_85 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_92 = {
    sizeof(struct SpatialInformationPos_ExtIEs__value),
    offsetof(struct SpatialInformationPos_ExtIEs__value, _asn_ctx),
    offsetof(struct SpatialInformationPos_ExtIEs__value, present),
    sizeof(((struct SpatialInformationPos_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_92 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_92 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_SpatialInformationPos_ExtIEs_89[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct SpatialInformationPos_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_90, memb_id_constraint_89},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct SpatialInformationPos_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_91, memb_criticality_constraint_89},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct SpatialInformationPos_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_92,
     0,
     {0, &asn_PER_memb_value_constr_92, memb_value_constraint_89},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_SpatialInformationPos_ExtIEs_tags_89[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_SpatialInformationPos_ExtIEs_tag2el_89[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_SpatialInformationPos_ExtIEs_specs_89 = {
    sizeof(struct SpatialInformationPos_ExtIEs),
    offsetof(struct SpatialInformationPos_ExtIEs, _asn_ctx),
    asn_MAP_SpatialInformationPos_ExtIEs_tag2el_89,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_SpatialInformationPos_ExtIEs = {
    "SpatialInformationPos-ExtIEs",
    "SpatialInformationPos-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_SpatialInformationPos_ExtIEs_tags_89,
    sizeof(asn_DEF_SpatialInformationPos_ExtIEs_tags_89) /
        sizeof(asn_DEF_SpatialInformationPos_ExtIEs_tags_89[0]), /* 1 */
    asn_DEF_SpatialInformationPos_ExtIEs_tags_89, /* Same as above */
    sizeof(asn_DEF_SpatialInformationPos_ExtIEs_tags_89) /
        sizeof(asn_DEF_SpatialInformationPos_ExtIEs_tags_89[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_SpatialInformationPos_ExtIEs_89,
    3,                                             /* Elements count */
    &asn_SPC_SpatialInformationPos_ExtIEs_specs_89 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_96 = {
    sizeof(struct TimeStampSlotIndex_ExtIEs__value),
    offsetof(struct TimeStampSlotIndex_ExtIEs__value, _asn_ctx),
    offsetof(struct TimeStampSlotIndex_ExtIEs__value, present),
    sizeof(((struct TimeStampSlotIndex_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_96 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                      /* No members */
        &asn_SPC_value_specs_96 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TimeStampSlotIndex_ExtIEs_93[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TimeStampSlotIndex_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_94, memb_id_constraint_93},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TimeStampSlotIndex_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_95, memb_criticality_constraint_93},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TimeStampSlotIndex_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_96,
     0,
     {0, &asn_PER_memb_value_constr_96, memb_value_constraint_93},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TimeStampSlotIndex_ExtIEs_tag2el_93[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TimeStampSlotIndex_ExtIEs_specs_93 = {
    sizeof(struct TimeStampSlotIndex_ExtIEs),
    offsetof(struct TimeStampSlotIndex_ExtIEs, _asn_ctx),
    asn_MAP_TimeStampSlotIndex_ExtIEs_tag2el_93,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TimeStampSlotIndex_ExtIEs = {
    "TimeStampSlotIndex-ExtIEs",
    "TimeStampSlotIndex-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93,
    sizeof(asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93) /
        sizeof(asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93[0]), /* 1 */
    asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93, /* Same as above */
    sizeof(asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93) /
        sizeof(asn_DEF_TimeStampSlotIndex_ExtIEs_tags_93[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TimeStampSlotIndex_ExtIEs_93,
    3,                                          /* Elements count */
    &asn_SPC_TimeStampSlotIndex_ExtIEs_specs_93 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_100 = {
    sizeof(struct TransmissionComb_ExtIEs__value),
    offsetof(struct TransmissionComb_ExtIEs__value, _asn_ctx),
    offsetof(struct TransmissionComb_ExtIEs__value, present),
    sizeof(((struct TransmissionComb_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_100 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_100 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TransmissionComb_ExtIEs_97[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TransmissionComb_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_98, memb_id_constraint_97},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TransmissionComb_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_99, memb_criticality_constraint_97},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TransmissionComb_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_100,
     0,
     {0, &asn_PER_memb_value_constr_100, memb_value_constraint_97},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TransmissionComb_ExtIEs_tags_97[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_TransmissionComb_ExtIEs_tag2el_97[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TransmissionComb_ExtIEs_specs_97 = {
    sizeof(struct TransmissionComb_ExtIEs),
    offsetof(struct TransmissionComb_ExtIEs, _asn_ctx),
    asn_MAP_TransmissionComb_ExtIEs_tag2el_97,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TransmissionComb_ExtIEs = {
    "TransmissionComb-ExtIEs",
    "TransmissionComb-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TransmissionComb_ExtIEs_tags_97,
    sizeof(asn_DEF_TransmissionComb_ExtIEs_tags_97) /
        sizeof(asn_DEF_TransmissionComb_ExtIEs_tags_97[0]), /* 1 */
    asn_DEF_TransmissionComb_ExtIEs_tags_97,                /* Same as above */
    sizeof(asn_DEF_TransmissionComb_ExtIEs_tags_97) /
        sizeof(asn_DEF_TransmissionComb_ExtIEs_tags_97[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TransmissionComb_ExtIEs_97,
    3,                                        /* Elements count */
    &asn_SPC_TransmissionComb_ExtIEs_specs_97 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_104 = {
    sizeof(struct TransmissionCombPos_ExtIEs__value),
    offsetof(struct TransmissionCombPos_ExtIEs__value, _asn_ctx),
    offsetof(struct TransmissionCombPos_ExtIEs__value, present),
    sizeof(((struct TransmissionCombPos_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_104 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_104 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TransmissionCombPos_ExtIEs_101[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TransmissionCombPos_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_102, memb_id_constraint_101},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TransmissionCombPos_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_103, memb_criticality_constraint_101},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TransmissionCombPos_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_104,
     0,
     {0, &asn_PER_memb_value_constr_104, memb_value_constraint_101},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TransmissionCombPos_ExtIEs_tags_101[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TransmissionCombPos_ExtIEs_tag2el_101[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TransmissionCombPos_ExtIEs_specs_101 = {
    sizeof(struct TransmissionCombPos_ExtIEs),
    offsetof(struct TransmissionCombPos_ExtIEs, _asn_ctx),
    asn_MAP_TransmissionCombPos_ExtIEs_tag2el_101,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TransmissionCombPos_ExtIEs = {
    "TransmissionCombPos-ExtIEs",
    "TransmissionCombPos-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TransmissionCombPos_ExtIEs_tags_101,
    sizeof(asn_DEF_TransmissionCombPos_ExtIEs_tags_101) /
        sizeof(asn_DEF_TransmissionCombPos_ExtIEs_tags_101[0]), /* 1 */
    asn_DEF_TransmissionCombPos_ExtIEs_tags_101, /* Same as above */
    sizeof(asn_DEF_TransmissionCombPos_ExtIEs_tags_101) /
        sizeof(asn_DEF_TransmissionCombPos_ExtIEs_tags_101[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TransmissionCombPos_ExtIEs_101,
    3,                                            /* Elements count */
    &asn_SPC_TransmissionCombPos_ExtIEs_specs_101 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_108 = {
    sizeof(struct TrpMeasuredResultsValue_ExtIEs__value),
    offsetof(struct TrpMeasuredResultsValue_ExtIEs__value, _asn_ctx),
    offsetof(struct TrpMeasuredResultsValue_ExtIEs__value, present),
    sizeof(((struct TrpMeasuredResultsValue_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_108 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_108 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TrpMeasuredResultsValue_ExtIEs_105[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TrpMeasuredResultsValue_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_106, memb_id_constraint_105},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TrpMeasuredResultsValue_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_107, memb_criticality_constraint_105},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TrpMeasuredResultsValue_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_108,
     0,
     {0, &asn_PER_memb_value_constr_108, memb_value_constraint_105},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TrpMeasuredResultsValue_ExtIEs_tag2el_105[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TrpMeasuredResultsValue_ExtIEs_specs_105 = {
    sizeof(struct TrpMeasuredResultsValue_ExtIEs),
    offsetof(struct TrpMeasuredResultsValue_ExtIEs, _asn_ctx),
    asn_MAP_TrpMeasuredResultsValue_ExtIEs_tag2el_105,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TrpMeasuredResultsValue_ExtIEs = {
    "TrpMeasuredResultsValue-ExtIEs",
    "TrpMeasuredResultsValue-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105,
    sizeof(asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105) /
        sizeof(asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105[0]), /* 1 */
    asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105, /* Same as above */
    sizeof(asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105) /
        sizeof(asn_DEF_TrpMeasuredResultsValue_ExtIEs_tags_105[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TrpMeasuredResultsValue_ExtIEs_105,
    3,                                                /* Elements count */
    &asn_SPC_TrpMeasuredResultsValue_ExtIEs_specs_105 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_112 = {
    sizeof(struct TrpMeasurementQuality_ExtIEs__value),
    offsetof(struct TrpMeasurementQuality_ExtIEs__value, _asn_ctx),
    offsetof(struct TrpMeasurementQuality_ExtIEs__value, present),
    sizeof(((struct TrpMeasurementQuality_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_112 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_112 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TrpMeasurementQuality_ExtIEs_109[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TrpMeasurementQuality_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_110, memb_id_constraint_109},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TrpMeasurementQuality_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_111, memb_criticality_constraint_109},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TrpMeasurementQuality_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_112,
     0,
     {0, &asn_PER_memb_value_constr_112, memb_value_constraint_109},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TrpMeasurementQuality_ExtIEs_tag2el_109[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TrpMeasurementQuality_ExtIEs_specs_109 = {
    sizeof(struct TrpMeasurementQuality_ExtIEs),
    offsetof(struct TrpMeasurementQuality_ExtIEs, _asn_ctx),
    asn_MAP_TrpMeasurementQuality_ExtIEs_tag2el_109,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TrpMeasurementQuality_ExtIEs = {
    "TrpMeasurementQuality-ExtIEs",
    "TrpMeasurementQuality-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109,
    sizeof(asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109) /
        sizeof(asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109[0]), /* 1 */
    asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109, /* Same as above */
    sizeof(asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109) /
        sizeof(asn_DEF_TrpMeasurementQuality_ExtIEs_tags_109[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TrpMeasurementQuality_ExtIEs_109,
    3,                                              /* Elements count */
    &asn_SPC_TrpMeasurementQuality_ExtIEs_specs_109 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_116 = {
    sizeof(struct TRPInformationItem_ExtIEs__value),
    offsetof(struct TRPInformationItem_ExtIEs__value, _asn_ctx),
    offsetof(struct TRPInformationItem_ExtIEs__value, present),
    sizeof(((struct TRPInformationItem_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_116 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_116 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPInformationItem_ExtIEs_113[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationItem_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_114, memb_id_constraint_113},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationItem_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_115, memb_criticality_constraint_113},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationItem_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_116,
     0,
     {0, &asn_PER_memb_value_constr_116, memb_value_constraint_113},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPInformationItem_ExtIEs_tags_113[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPInformationItem_ExtIEs_tag2el_113[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPInformationItem_ExtIEs_specs_113 = {
    sizeof(struct TRPInformationItem_ExtIEs),
    offsetof(struct TRPInformationItem_ExtIEs, _asn_ctx),
    asn_MAP_TRPInformationItem_ExtIEs_tag2el_113,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPInformationItem_ExtIEs = {
    "TRPInformationItem-ExtIEs",
    "TRPInformationItem-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPInformationItem_ExtIEs_tags_113,
    sizeof(asn_DEF_TRPInformationItem_ExtIEs_tags_113) /
        sizeof(asn_DEF_TRPInformationItem_ExtIEs_tags_113[0]), /* 1 */
    asn_DEF_TRPInformationItem_ExtIEs_tags_113, /* Same as above */
    sizeof(asn_DEF_TRPInformationItem_ExtIEs_tags_113) /
        sizeof(asn_DEF_TRPInformationItem_ExtIEs_tags_113[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPInformationItem_ExtIEs_113,
    3,                                           /* Elements count */
    &asn_SPC_TRPInformationItem_ExtIEs_specs_113 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_120 = {
    sizeof(struct TRPPositionDefinitionType_ExtIEs__value),
    offsetof(struct TRPPositionDefinitionType_ExtIEs__value, _asn_ctx),
    offsetof(struct TRPPositionDefinitionType_ExtIEs__value, present),
    sizeof(((struct TRPPositionDefinitionType_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_120 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_120 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPPositionDefinitionType_ExtIEs_117[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPPositionDefinitionType_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_118, memb_id_constraint_117},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPPositionDefinitionType_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_119, memb_criticality_constraint_117},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPPositionDefinitionType_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_120,
     0,
     {0, &asn_PER_memb_value_constr_120, memb_value_constraint_117},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPPositionDefinitionType_ExtIEs_tag2el_117[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPPositionDefinitionType_ExtIEs_specs_117 = {
    sizeof(struct TRPPositionDefinitionType_ExtIEs),
    offsetof(struct TRPPositionDefinitionType_ExtIEs, _asn_ctx),
    asn_MAP_TRPPositionDefinitionType_ExtIEs_tag2el_117,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPPositionDefinitionType_ExtIEs = {
    "TRPPositionDefinitionType-ExtIEs",
    "TRPPositionDefinitionType-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117,
    sizeof(asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117) /
        sizeof(asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117[0]), /* 1 */
    asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117, /* Same as above */
    sizeof(asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117) /
        sizeof(asn_DEF_TRPPositionDefinitionType_ExtIEs_tags_117[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPPositionDefinitionType_ExtIEs_117,
    3,                                                  /* Elements count */
    &asn_SPC_TRPPositionDefinitionType_ExtIEs_specs_117 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_124 = {
    sizeof(struct TRPPositionDirectAccuracy_ExtIEs__value),
    offsetof(struct TRPPositionDirectAccuracy_ExtIEs__value, _asn_ctx),
    offsetof(struct TRPPositionDirectAccuracy_ExtIEs__value, present),
    sizeof(((struct TRPPositionDirectAccuracy_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_124 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_124 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPPositionDirectAccuracy_ExtIEs_121[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPPositionDirectAccuracy_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_122, memb_id_constraint_121},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPPositionDirectAccuracy_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_123, memb_criticality_constraint_121},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPPositionDirectAccuracy_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_124,
     0,
     {0, &asn_PER_memb_value_constr_124, memb_value_constraint_121},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPPositionDirectAccuracy_ExtIEs_tag2el_121[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPPositionDirectAccuracy_ExtIEs_specs_121 = {
    sizeof(struct TRPPositionDirectAccuracy_ExtIEs),
    offsetof(struct TRPPositionDirectAccuracy_ExtIEs, _asn_ctx),
    asn_MAP_TRPPositionDirectAccuracy_ExtIEs_tag2el_121,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPPositionDirectAccuracy_ExtIEs = {
    "TRPPositionDirectAccuracy-ExtIEs",
    "TRPPositionDirectAccuracy-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121,
    sizeof(asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121) /
        sizeof(asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121[0]), /* 1 */
    asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121, /* Same as above */
    sizeof(asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121) /
        sizeof(asn_DEF_TRPPositionDirectAccuracy_ExtIEs_tags_121[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPPositionDirectAccuracy_ExtIEs_121,
    3,                                                  /* Elements count */
    &asn_SPC_TRPPositionDirectAccuracy_ExtIEs_specs_121 /* Additional specs */
};

static asn_CHOICE_specifics_t asn_SPC_value_specs_128 = {
    sizeof(struct TRPReferencePointType_ExtIEs__value),
    offsetof(struct TRPReferencePointType_ExtIEs__value, _asn_ctx),
    offsetof(struct TRPReferencePointType_ExtIEs__value, present),
    sizeof(((struct TRPReferencePointType_ExtIEs__value*) 0)->present),
    0, /* No top level tags */
    0, /* No tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_128 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        0,
        0,                       /* No members */
        &asn_SPC_value_specs_128 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPReferencePointType_ExtIEs_125[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPReferencePointType_ExtIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_126, memb_id_constraint_125},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPReferencePointType_ExtIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     0,
     {0, &asn_PER_memb_criticality_constr_127, memb_criticality_constraint_125},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPReferencePointType_ExtIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_128,
     0,
     {0, &asn_PER_memb_value_constr_128, memb_value_constraint_125},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPReferencePointType_ExtIEs_tags_125[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPReferencePointType_ExtIEs_tag2el_125[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPReferencePointType_ExtIEs_specs_125 = {
    sizeof(struct TRPReferencePointType_ExtIEs),
    offsetof(struct TRPReferencePointType_ExtIEs, _asn_ctx),
    asn_MAP_TRPReferencePointType_ExtIEs_tag2el_125,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPReferencePointType_ExtIEs = {
    "TRPReferencePointType-ExtIEs",
    "TRPReferencePointType-ExtIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPReferencePointType_ExtIEs_tags_125,
    sizeof(asn_DEF_TRPReferencePointType_ExtIEs_tags_125) /
        sizeof(asn_DEF_TRPReferencePointType_ExtIEs_tags_125[0]), /* 1 */
    asn_DEF_TRPReferencePointType_ExtIEs_tags_125, /* Same as above */
    sizeof(asn_DEF_TRPReferencePointType_ExtIEs_tags_125) /
        sizeof(asn_DEF_TRPReferencePointType_ExtIEs_tags_125[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPReferencePointType_ExtIEs_125,
    3,                                              /* Elements count */
    &asn_SPC_TRPReferencePointType_ExtIEs_specs_125 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_132[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct WLANMeasurementQuantities_ItemIEs__value,
         choice.WLANMeasurementQuantities_Item),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_WLANMeasurementQuantities_Item,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "WLANMeasurementQuantities-Item"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_132[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* WLANMeasurementQuantities-Item */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_132 = {
    sizeof(struct WLANMeasurementQuantities_ItemIEs__value),
    offsetof(struct WLANMeasurementQuantities_ItemIEs__value, _asn_ctx),
    offsetof(struct WLANMeasurementQuantities_ItemIEs__value, present),
    sizeof(((struct WLANMeasurementQuantities_ItemIEs__value*) 0)->present),
    asn_MAP_value_tag2el_132,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_132 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_132,
        1,                       /* Elements count */
        &asn_SPC_value_specs_132 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_WLANMeasurementQuantities_ItemIEs_129[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct WLANMeasurementQuantities_ItemIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_130, memb_id_constraint_129},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct WLANMeasurementQuantities_ItemIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_WLANMeasurementQuantities_ItemIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_131, memb_criticality_constraint_129},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct WLANMeasurementQuantities_ItemIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_132,
     select_WLANMeasurementQuantities_ItemIEs_value_type,
     {0, &asn_PER_memb_value_constr_132, memb_value_constraint_129},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_WLANMeasurementQuantities_ItemIEs_tag2el_129[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_WLANMeasurementQuantities_ItemIEs_specs_129 = {
    sizeof(struct WLANMeasurementQuantities_ItemIEs),
    offsetof(struct WLANMeasurementQuantities_ItemIEs, _asn_ctx),
    asn_MAP_WLANMeasurementQuantities_ItemIEs_tag2el_129,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_WLANMeasurementQuantities_ItemIEs = {
    "WLANMeasurementQuantities-ItemIEs",
    "WLANMeasurementQuantities-ItemIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129,
    sizeof(asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129) /
        sizeof(asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129[0]), /* 1 */
    asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129, /* Same as above */
    sizeof(asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129) /
        sizeof(asn_DEF_WLANMeasurementQuantities_ItemIEs_tags_129[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_WLANMeasurementQuantities_ItemIEs_129,
    3,                                                   /* Elements count */
    &asn_SPC_WLANMeasurementQuantities_ItemIEs_specs_129 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_136[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationRequest_IEs__value,
         choice.UE_Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationRequest_IEs__value,
         choice.ReportCharacteristics),
     (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
     0,
     &asn_DEF_ReportCharacteristics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ReportCharacteristics"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationRequest_IEs__value,
         choice.MeasurementPeriodicity),
     (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
     0,
     &asn_DEF_MeasurementPeriodicity,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "MeasurementPeriodicity"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationRequest_IEs__value,
         choice.MeasurementQuantities),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_MeasurementQuantities,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "MeasurementQuantities"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationRequest_IEs__value,
         choice.OtherRATMeasurementQuantities),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_OtherRATMeasurementQuantities,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "OtherRATMeasurementQuantities"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationRequest_IEs__value,
         choice.WLANMeasurementQuantities),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_WLANMeasurementQuantities,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "WLANMeasurementQuantities"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_136[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0}, /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0,
     1}, /* ReportCharacteristics */
    {(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 2, -1,
     0}, /* MeasurementPeriodicity */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 3, 0,
     2}, /* MeasurementQuantities */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 4, -1,
     1}, /* OtherRATMeasurementQuantities */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 5, -2,
     0} /* WLANMeasurementQuantities */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_136 = {
    sizeof(struct E_CIDMeasurementInitiationRequest_IEs__value),
    offsetof(struct E_CIDMeasurementInitiationRequest_IEs__value, _asn_ctx),
    offsetof(struct E_CIDMeasurementInitiationRequest_IEs__value, present),
    sizeof(((struct E_CIDMeasurementInitiationRequest_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_136,
    6, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_136 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_136,
        6,                       /* Elements count */
        &asn_SPC_value_specs_136 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_E_CIDMeasurementInitiationRequest_IEs_133[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationRequest_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_134, memb_id_constraint_133},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationRequest_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_E_CIDMeasurementInitiationRequest_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_135, memb_criticality_constraint_133},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationRequest_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_136,
     select_E_CIDMeasurementInitiationRequest_IEs_value_type,
     {0, &asn_PER_memb_value_constr_136, memb_value_constraint_133},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_E_CIDMeasurementInitiationRequest_IEs_tag2el_133[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_E_CIDMeasurementInitiationRequest_IEs_specs_133 = {
        sizeof(struct E_CIDMeasurementInitiationRequest_IEs),
        offsetof(struct E_CIDMeasurementInitiationRequest_IEs, _asn_ctx),
        asn_MAP_E_CIDMeasurementInitiationRequest_IEs_tag2el_133,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_E_CIDMeasurementInitiationRequest_IEs = {
    "E-CIDMeasurementInitiationRequest-IEs",
    "E-CIDMeasurementInitiationRequest-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133,
    sizeof(asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133) /
        sizeof(
            asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133[0]), /* 1 */
    asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133, /* Same as above */
    sizeof(asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133) /
        sizeof(
            asn_DEF_E_CIDMeasurementInitiationRequest_IEs_tags_133[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_E_CIDMeasurementInitiationRequest_IEs_133,
    3, /* Elements count */
    &asn_SPC_E_CIDMeasurementInitiationRequest_IEs_specs_133 /* Additional specs
                                                              */
};

static asn_TYPE_member_t asn_MBR_value_140[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.UE_Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.UE_Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.E_CID_MeasurementResult),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_E_CID_MeasurementResult,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "E-CID-MeasurementResult"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.Cell_Portion_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Cell_Portion_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cell-Portion-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.OtherRATMeasurementResult),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_OtherRATMeasurementResult,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "OtherRATMeasurementResult"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationResponse_IEs__value,
         choice.WLANMeasurementResult),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_WLANMeasurementResult,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "WLANMeasurementResult"},
};
static const unsigned asn_MAP_value_to_canonical_140[] = {0, 1, 4, 2, 3, 5, 6};
static const unsigned asn_MAP_value_from_canonical_140[]      = {0, 1, 3, 4,
                                                            2, 5, 6};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_140[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 2},  /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 1}, /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 4, -2, 0}, /* Cell-Portion-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0,
     3}, /* E-CID-MeasurementResult */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 3, -1,
     2}, /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 5, -2,
     1}, /* OtherRATMeasurementResult */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 6, -3,
     0} /* WLANMeasurementResult */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_140 = {
    sizeof(struct E_CIDMeasurementInitiationResponse_IEs__value),
    offsetof(struct E_CIDMeasurementInitiationResponse_IEs__value, _asn_ctx),
    offsetof(struct E_CIDMeasurementInitiationResponse_IEs__value, present),
    sizeof(
        ((struct E_CIDMeasurementInitiationResponse_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_140,
    7, /* Count of tags in the map */
    asn_MAP_value_to_canonical_140,
    asn_MAP_value_from_canonical_140,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_140 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_140,
        7,                       /* Elements count */
        &asn_SPC_value_specs_140 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_E_CIDMeasurementInitiationResponse_IEs_137[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationResponse_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_138, memb_id_constraint_137},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationResponse_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_E_CIDMeasurementInitiationResponse_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_139, memb_criticality_constraint_137},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationResponse_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_140,
     select_E_CIDMeasurementInitiationResponse_IEs_value_type,
     {0, &asn_PER_memb_value_constr_140, memb_value_constraint_137},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_E_CIDMeasurementInitiationResponse_IEs_tag2el_137[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_E_CIDMeasurementInitiationResponse_IEs_specs_137 = {
        sizeof(struct E_CIDMeasurementInitiationResponse_IEs),
        offsetof(struct E_CIDMeasurementInitiationResponse_IEs, _asn_ctx),
        asn_MAP_E_CIDMeasurementInitiationResponse_IEs_tag2el_137,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_E_CIDMeasurementInitiationResponse_IEs = {
    "E-CIDMeasurementInitiationResponse-IEs",
    "E-CIDMeasurementInitiationResponse-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137,
    sizeof(asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137) /
        sizeof(
            asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137[0]), /* 1 */
    asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137, /* Same as above */
    sizeof(asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137) /
        sizeof(
            asn_DEF_E_CIDMeasurementInitiationResponse_IEs_tags_137[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_E_CIDMeasurementInitiationResponse_IEs_137,
    3, /* Elements count */
    &asn_SPC_E_CIDMeasurementInitiationResponse_IEs_specs_137 /* Additional
                                                                 specs */
};

static asn_TYPE_member_t asn_MBR_value_144[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationFailure_IEs__value,
         choice.UE_Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationFailure_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementInitiationFailure_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_144[]        = {0, 2, 1};
static const unsigned asn_MAP_value_from_canonical_144[]      = {0, 2, 1};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_144[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0}, /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 1, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 1, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 1, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_144 = {
    sizeof(struct E_CIDMeasurementInitiationFailure_IEs__value),
    offsetof(struct E_CIDMeasurementInitiationFailure_IEs__value, _asn_ctx),
    offsetof(struct E_CIDMeasurementInitiationFailure_IEs__value, present),
    sizeof(((struct E_CIDMeasurementInitiationFailure_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_144,
    6, /* Count of tags in the map */
    asn_MAP_value_to_canonical_144,
    asn_MAP_value_from_canonical_144,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_144 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_144,
        3,                       /* Elements count */
        &asn_SPC_value_specs_144 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_E_CIDMeasurementInitiationFailure_IEs_141[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationFailure_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_142, memb_id_constraint_141},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationFailure_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_E_CIDMeasurementInitiationFailure_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_143, memb_criticality_constraint_141},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementInitiationFailure_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_144,
     select_E_CIDMeasurementInitiationFailure_IEs_value_type,
     {0, &asn_PER_memb_value_constr_144, memb_value_constraint_141},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_E_CIDMeasurementInitiationFailure_IEs_tag2el_141[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_E_CIDMeasurementInitiationFailure_IEs_specs_141 = {
        sizeof(struct E_CIDMeasurementInitiationFailure_IEs),
        offsetof(struct E_CIDMeasurementInitiationFailure_IEs, _asn_ctx),
        asn_MAP_E_CIDMeasurementInitiationFailure_IEs_tag2el_141,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_E_CIDMeasurementInitiationFailure_IEs = {
    "E-CIDMeasurementInitiationFailure-IEs",
    "E-CIDMeasurementInitiationFailure-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141,
    sizeof(asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141) /
        sizeof(
            asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141[0]), /* 1 */
    asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141, /* Same as above */
    sizeof(asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141) /
        sizeof(
            asn_DEF_E_CIDMeasurementInitiationFailure_IEs_tags_141[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_E_CIDMeasurementInitiationFailure_IEs_141,
    3, /* Elements count */
    &asn_SPC_E_CIDMeasurementInitiationFailure_IEs_specs_141 /* Additional specs
                                                              */
};

static asn_TYPE_member_t asn_MBR_value_148[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementFailureIndication_IEs__value,
         choice.UE_Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementFailureIndication_IEs__value,
         choice.UE_Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementFailureIndication_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_148[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1},  /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0}, /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 2, 0, 0},    /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 2, 0, 0},    /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0},    /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 2, 0, 0}     /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_148 = {
    sizeof(struct E_CIDMeasurementFailureIndication_IEs__value),
    offsetof(struct E_CIDMeasurementFailureIndication_IEs__value, _asn_ctx),
    offsetof(struct E_CIDMeasurementFailureIndication_IEs__value, present),
    sizeof(((struct E_CIDMeasurementFailureIndication_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_148,
    6, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_148 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_148,
        3,                       /* Elements count */
        &asn_SPC_value_specs_148 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_E_CIDMeasurementFailureIndication_IEs_145[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementFailureIndication_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_146, memb_id_constraint_145},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementFailureIndication_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_E_CIDMeasurementFailureIndication_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_147, memb_criticality_constraint_145},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementFailureIndication_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_148,
     select_E_CIDMeasurementFailureIndication_IEs_value_type,
     {0, &asn_PER_memb_value_constr_148, memb_value_constraint_145},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_E_CIDMeasurementFailureIndication_IEs_tag2el_145[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_E_CIDMeasurementFailureIndication_IEs_specs_145 = {
        sizeof(struct E_CIDMeasurementFailureIndication_IEs),
        offsetof(struct E_CIDMeasurementFailureIndication_IEs, _asn_ctx),
        asn_MAP_E_CIDMeasurementFailureIndication_IEs_tag2el_145,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_E_CIDMeasurementFailureIndication_IEs = {
    "E-CIDMeasurementFailureIndication-IEs",
    "E-CIDMeasurementFailureIndication-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145,
    sizeof(asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145) /
        sizeof(
            asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145[0]), /* 1 */
    asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145, /* Same as above */
    sizeof(asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145) /
        sizeof(
            asn_DEF_E_CIDMeasurementFailureIndication_IEs_tags_145[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_E_CIDMeasurementFailureIndication_IEs_145,
    3, /* Elements count */
    &asn_SPC_E_CIDMeasurementFailureIndication_IEs_specs_145 /* Additional specs
                                                              */
};

static asn_TYPE_member_t asn_MBR_value_152[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementReport_IEs__value, choice.UE_Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementReport_IEs__value, choice.UE_Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementReport_IEs__value,
         choice.E_CID_MeasurementResult),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_E_CID_MeasurementResult,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "E-CID-MeasurementResult"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementReport_IEs__value, choice.Cell_Portion_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Cell_Portion_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cell-Portion-ID"},
};
static const unsigned asn_MAP_value_to_canonical_152[]        = {0, 1, 3, 2};
static const unsigned asn_MAP_value_from_canonical_152[]      = {0, 1, 3, 2};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_152[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 2},  /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 1}, /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 3, -2, 0}, /* Cell-Portion-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0,
     0} /* E-CID-MeasurementResult */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_152 = {
    sizeof(struct E_CIDMeasurementReport_IEs__value),
    offsetof(struct E_CIDMeasurementReport_IEs__value, _asn_ctx),
    offsetof(struct E_CIDMeasurementReport_IEs__value, present),
    sizeof(((struct E_CIDMeasurementReport_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_152,
    4, /* Count of tags in the map */
    asn_MAP_value_to_canonical_152,
    asn_MAP_value_from_canonical_152,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_152 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_152,
        4,                       /* Elements count */
        &asn_SPC_value_specs_152 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_E_CIDMeasurementReport_IEs_149[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementReport_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_150, memb_id_constraint_149},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementReport_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_E_CIDMeasurementReport_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_151, memb_criticality_constraint_149},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementReport_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_152,
     select_E_CIDMeasurementReport_IEs_value_type,
     {0, &asn_PER_memb_value_constr_152, memb_value_constraint_149},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_E_CIDMeasurementReport_IEs_tags_149[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_E_CIDMeasurementReport_IEs_tag2el_149[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_E_CIDMeasurementReport_IEs_specs_149 = {
    sizeof(struct E_CIDMeasurementReport_IEs),
    offsetof(struct E_CIDMeasurementReport_IEs, _asn_ctx),
    asn_MAP_E_CIDMeasurementReport_IEs_tag2el_149,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_E_CIDMeasurementReport_IEs = {
    "E-CIDMeasurementReport-IEs",
    "E-CIDMeasurementReport-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_E_CIDMeasurementReport_IEs_tags_149,
    sizeof(asn_DEF_E_CIDMeasurementReport_IEs_tags_149) /
        sizeof(asn_DEF_E_CIDMeasurementReport_IEs_tags_149[0]), /* 1 */
    asn_DEF_E_CIDMeasurementReport_IEs_tags_149, /* Same as above */
    sizeof(asn_DEF_E_CIDMeasurementReport_IEs_tags_149) /
        sizeof(asn_DEF_E_CIDMeasurementReport_IEs_tags_149[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_E_CIDMeasurementReport_IEs_149,
    3,                                            /* Elements count */
    &asn_SPC_E_CIDMeasurementReport_IEs_specs_149 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_156[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementTerminationCommand_IEs__value,
         choice.UE_Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct E_CIDMeasurementTerminationCommand_IEs__value,
         choice.UE_Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_UE_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "UE-Measurement-ID"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_156[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1}, /* UE-Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0} /* UE-Measurement-ID */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_156 = {
    sizeof(struct E_CIDMeasurementTerminationCommand_IEs__value),
    offsetof(struct E_CIDMeasurementTerminationCommand_IEs__value, _asn_ctx),
    offsetof(struct E_CIDMeasurementTerminationCommand_IEs__value, present),
    sizeof(
        ((struct E_CIDMeasurementTerminationCommand_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_156,
    2, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_156 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_156,
        2,                       /* Elements count */
        &asn_SPC_value_specs_156 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_E_CIDMeasurementTerminationCommand_IEs_153[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementTerminationCommand_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_154, memb_id_constraint_153},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementTerminationCommand_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_E_CIDMeasurementTerminationCommand_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_155, memb_criticality_constraint_153},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct E_CIDMeasurementTerminationCommand_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_156,
     select_E_CIDMeasurementTerminationCommand_IEs_value_type,
     {0, &asn_PER_memb_value_constr_156, memb_value_constraint_153},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_E_CIDMeasurementTerminationCommand_IEs_tag2el_153[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t
    asn_SPC_E_CIDMeasurementTerminationCommand_IEs_specs_153 = {
        sizeof(struct E_CIDMeasurementTerminationCommand_IEs),
        offsetof(struct E_CIDMeasurementTerminationCommand_IEs, _asn_ctx),
        asn_MAP_E_CIDMeasurementTerminationCommand_IEs_tag2el_153,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_E_CIDMeasurementTerminationCommand_IEs = {
    "E-CIDMeasurementTerminationCommand-IEs",
    "E-CIDMeasurementTerminationCommand-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153,
    sizeof(asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153) /
        sizeof(
            asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153[0]), /* 1 */
    asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153, /* Same as above */
    sizeof(asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153) /
        sizeof(
            asn_DEF_E_CIDMeasurementTerminationCommand_IEs_tags_153[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_E_CIDMeasurementTerminationCommand_IEs_153,
    3, /* Elements count */
    &asn_SPC_E_CIDMeasurementTerminationCommand_IEs_specs_153 /* Additional
                                                                 specs */
};

static asn_TYPE_member_t asn_MBR_value_160[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OTDOAInformationRequest_IEs__value,
         choice.OTDOA_Information_Type),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_OTDOA_Information_Type,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "OTDOA-Information-Type"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_160[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* OTDOA-Information-Type */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_160 = {
    sizeof(struct OTDOAInformationRequest_IEs__value),
    offsetof(struct OTDOAInformationRequest_IEs__value, _asn_ctx),
    offsetof(struct OTDOAInformationRequest_IEs__value, present),
    sizeof(((struct OTDOAInformationRequest_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_160,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_160 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_160,
        1,                       /* Elements count */
        &asn_SPC_value_specs_160 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OTDOAInformationRequest_IEs_157[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationRequest_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_158, memb_id_constraint_157},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationRequest_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OTDOAInformationRequest_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_159, memb_criticality_constraint_157},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationRequest_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_160,
     select_OTDOAInformationRequest_IEs_value_type,
     {0, &asn_PER_memb_value_constr_160, memb_value_constraint_157},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_OTDOAInformationRequest_IEs_tags_157[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OTDOAInformationRequest_IEs_tag2el_157[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_OTDOAInformationRequest_IEs_specs_157 = {
    sizeof(struct OTDOAInformationRequest_IEs),
    offsetof(struct OTDOAInformationRequest_IEs, _asn_ctx),
    asn_MAP_OTDOAInformationRequest_IEs_tag2el_157,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OTDOAInformationRequest_IEs = {
    "OTDOAInformationRequest-IEs",
    "OTDOAInformationRequest-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_OTDOAInformationRequest_IEs_tags_157,
    sizeof(asn_DEF_OTDOAInformationRequest_IEs_tags_157) /
        sizeof(asn_DEF_OTDOAInformationRequest_IEs_tags_157[0]), /* 1 */
    asn_DEF_OTDOAInformationRequest_IEs_tags_157, /* Same as above */
    sizeof(asn_DEF_OTDOAInformationRequest_IEs_tags_157) /
        sizeof(asn_DEF_OTDOAInformationRequest_IEs_tags_157[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OTDOAInformationRequest_IEs_157,
    3,                                             /* Elements count */
    &asn_SPC_OTDOAInformationRequest_IEs_specs_157 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_164[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationResponse_IEs__value, choice.OTDOACells),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_OTDOACells,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "OTDOACells"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OTDOAInformationResponse_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_164[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 1}, /* OTDOACells */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1,
     0} /* CriticalityDiagnostics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_164 = {
    sizeof(struct OTDOAInformationResponse_IEs__value),
    offsetof(struct OTDOAInformationResponse_IEs__value, _asn_ctx),
    offsetof(struct OTDOAInformationResponse_IEs__value, present),
    sizeof(((struct OTDOAInformationResponse_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_164,
    2, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_164 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_164,
        2,                       /* Elements count */
        &asn_SPC_value_specs_164 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OTDOAInformationResponse_IEs_161[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationResponse_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_162, memb_id_constraint_161},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationResponse_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OTDOAInformationResponse_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_163, memb_criticality_constraint_161},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationResponse_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_164,
     select_OTDOAInformationResponse_IEs_value_type,
     {0, &asn_PER_memb_value_constr_164, memb_value_constraint_161},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_OTDOAInformationResponse_IEs_tags_161[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OTDOAInformationResponse_IEs_tag2el_161[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_OTDOAInformationResponse_IEs_specs_161 = {
    sizeof(struct OTDOAInformationResponse_IEs),
    offsetof(struct OTDOAInformationResponse_IEs, _asn_ctx),
    asn_MAP_OTDOAInformationResponse_IEs_tag2el_161,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OTDOAInformationResponse_IEs = {
    "OTDOAInformationResponse-IEs",
    "OTDOAInformationResponse-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_OTDOAInformationResponse_IEs_tags_161,
    sizeof(asn_DEF_OTDOAInformationResponse_IEs_tags_161) /
        sizeof(asn_DEF_OTDOAInformationResponse_IEs_tags_161[0]), /* 1 */
    asn_DEF_OTDOAInformationResponse_IEs_tags_161, /* Same as above */
    sizeof(asn_DEF_OTDOAInformationResponse_IEs_tags_161) /
        sizeof(asn_DEF_OTDOAInformationResponse_IEs_tags_161[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OTDOAInformationResponse_IEs_161,
    3,                                              /* Elements count */
    &asn_SPC_OTDOAInformationResponse_IEs_specs_161 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_168[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationFailure_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct OTDOAInformationFailure_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_168[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_168[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_168[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 0, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_168 = {
    sizeof(struct OTDOAInformationFailure_IEs__value),
    offsetof(struct OTDOAInformationFailure_IEs__value, _asn_ctx),
    offsetof(struct OTDOAInformationFailure_IEs__value, present),
    sizeof(((struct OTDOAInformationFailure_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_168,
    5, /* Count of tags in the map */
    asn_MAP_value_to_canonical_168,
    asn_MAP_value_from_canonical_168,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_168 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_168,
        2,                       /* Elements count */
        &asn_SPC_value_specs_168 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_OTDOAInformationFailure_IEs_165[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationFailure_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_166, memb_id_constraint_165},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationFailure_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_OTDOAInformationFailure_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_167, memb_criticality_constraint_165},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct OTDOAInformationFailure_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_168,
     select_OTDOAInformationFailure_IEs_value_type,
     {0, &asn_PER_memb_value_constr_168, memb_value_constraint_165},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_OTDOAInformationFailure_IEs_tags_165[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_OTDOAInformationFailure_IEs_tag2el_165[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_OTDOAInformationFailure_IEs_specs_165 = {
    sizeof(struct OTDOAInformationFailure_IEs),
    offsetof(struct OTDOAInformationFailure_IEs, _asn_ctx),
    asn_MAP_OTDOAInformationFailure_IEs_tag2el_165,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_OTDOAInformationFailure_IEs = {
    "OTDOAInformationFailure-IEs",
    "OTDOAInformationFailure-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_OTDOAInformationFailure_IEs_tags_165,
    sizeof(asn_DEF_OTDOAInformationFailure_IEs_tags_165) /
        sizeof(asn_DEF_OTDOAInformationFailure_IEs_tags_165[0]), /* 1 */
    asn_DEF_OTDOAInformationFailure_IEs_tags_165, /* Same as above */
    sizeof(asn_DEF_OTDOAInformationFailure_IEs_tags_165) /
        sizeof(asn_DEF_OTDOAInformationFailure_IEs_tags_165[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_OTDOAInformationFailure_IEs_165,
    3,                                             /* Elements count */
    &asn_SPC_OTDOAInformationFailure_IEs_specs_165 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_172[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct AssistanceInformationControl_IEs__value,
         choice.Assistance_Information),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_Assistance_Information,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Assistance-Information"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationControl_IEs__value, choice.Broadcast),
     (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
     0,
     &asn_DEF_Broadcast,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Broadcast"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct AssistanceInformationControl_IEs__value,
         choice.PositioningBroadcastCells),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_PositioningBroadcastCells,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "PositioningBroadcastCells"},
};
static const unsigned asn_MAP_value_to_canonical_172[]        = {1, 0, 2};
static const unsigned asn_MAP_value_from_canonical_172[]      = {1, 0, 2};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_172[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 1, 0, 0}, /* Broadcast */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     1}, /* Assistance-Information */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, -1,
     0} /* PositioningBroadcastCells */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_172 = {
    sizeof(struct AssistanceInformationControl_IEs__value),
    offsetof(struct AssistanceInformationControl_IEs__value, _asn_ctx),
    offsetof(struct AssistanceInformationControl_IEs__value, present),
    sizeof(((struct AssistanceInformationControl_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_172,
    3, /* Count of tags in the map */
    asn_MAP_value_to_canonical_172,
    asn_MAP_value_from_canonical_172,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_172 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_172,
        3,                       /* Elements count */
        &asn_SPC_value_specs_172 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_AssistanceInformationControl_IEs_169[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationControl_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_170, memb_id_constraint_169},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationControl_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_AssistanceInformationControl_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_171, memb_criticality_constraint_169},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationControl_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_172,
     select_AssistanceInformationControl_IEs_value_type,
     {0, &asn_PER_memb_value_constr_172, memb_value_constraint_169},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_AssistanceInformationControl_IEs_tags_169[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_AssistanceInformationControl_IEs_tag2el_169[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_AssistanceInformationControl_IEs_specs_169 = {
    sizeof(struct AssistanceInformationControl_IEs),
    offsetof(struct AssistanceInformationControl_IEs, _asn_ctx),
    asn_MAP_AssistanceInformationControl_IEs_tag2el_169,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_AssistanceInformationControl_IEs = {
    "AssistanceInformationControl-IEs",
    "AssistanceInformationControl-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_AssistanceInformationControl_IEs_tags_169,
    sizeof(asn_DEF_AssistanceInformationControl_IEs_tags_169) /
        sizeof(asn_DEF_AssistanceInformationControl_IEs_tags_169[0]), /* 1 */
    asn_DEF_AssistanceInformationControl_IEs_tags_169, /* Same as above */
    sizeof(asn_DEF_AssistanceInformationControl_IEs_tags_169) /
        sizeof(asn_DEF_AssistanceInformationControl_IEs_tags_169[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_AssistanceInformationControl_IEs_169,
    3,                                                  /* Elements count */
    &asn_SPC_AssistanceInformationControl_IEs_specs_169 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_176[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct AssistanceInformationFeedback_IEs__value,
         choice.AssistanceInformationFailureList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_AssistanceInformationFailureList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "AssistanceInformationFailureList"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct AssistanceInformationFeedback_IEs__value,
         choice.PositioningBroadcastCells),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_PositioningBroadcastCells,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "PositioningBroadcastCells"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct AssistanceInformationFeedback_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_176[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     2}, /* AssistanceInformationFailureList */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1,
     1}, /* PositioningBroadcastCells */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, -2,
     0} /* CriticalityDiagnostics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_176 = {
    sizeof(struct AssistanceInformationFeedback_IEs__value),
    offsetof(struct AssistanceInformationFeedback_IEs__value, _asn_ctx),
    offsetof(struct AssistanceInformationFeedback_IEs__value, present),
    sizeof(((struct AssistanceInformationFeedback_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_176,
    3, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_176 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_176,
        3,                       /* Elements count */
        &asn_SPC_value_specs_176 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_AssistanceInformationFeedback_IEs_173[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationFeedback_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_174, memb_id_constraint_173},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationFeedback_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_AssistanceInformationFeedback_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_175, memb_criticality_constraint_173},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct AssistanceInformationFeedback_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_176,
     select_AssistanceInformationFeedback_IEs_value_type,
     {0, &asn_PER_memb_value_constr_176, memb_value_constraint_173},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_AssistanceInformationFeedback_IEs_tags_173[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_AssistanceInformationFeedback_IEs_tag2el_173[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_AssistanceInformationFeedback_IEs_specs_173 = {
    sizeof(struct AssistanceInformationFeedback_IEs),
    offsetof(struct AssistanceInformationFeedback_IEs, _asn_ctx),
    asn_MAP_AssistanceInformationFeedback_IEs_tag2el_173,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_AssistanceInformationFeedback_IEs = {
    "AssistanceInformationFeedback-IEs",
    "AssistanceInformationFeedback-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_AssistanceInformationFeedback_IEs_tags_173,
    sizeof(asn_DEF_AssistanceInformationFeedback_IEs_tags_173) /
        sizeof(asn_DEF_AssistanceInformationFeedback_IEs_tags_173[0]), /* 1 */
    asn_DEF_AssistanceInformationFeedback_IEs_tags_173, /* Same as above */
    sizeof(asn_DEF_AssistanceInformationFeedback_IEs_tags_173) /
        sizeof(asn_DEF_AssistanceInformationFeedback_IEs_tags_173[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_AssistanceInformationFeedback_IEs_173,
    3,                                                   /* Elements count */
    &asn_SPC_AssistanceInformationFeedback_IEs_specs_173 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_180[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ErrorIndication_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ErrorIndication_IEs__value, choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_180[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_180[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_180[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 0, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_180 = {
    sizeof(struct ErrorIndication_IEs__value),
    offsetof(struct ErrorIndication_IEs__value, _asn_ctx),
    offsetof(struct ErrorIndication_IEs__value, present),
    sizeof(((struct ErrorIndication_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_180,
    5, /* Count of tags in the map */
    asn_MAP_value_to_canonical_180,
    asn_MAP_value_from_canonical_180,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_180 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_180,
        2,                       /* Elements count */
        &asn_SPC_value_specs_180 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_ErrorIndication_IEs_177[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct ErrorIndication_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_178, memb_id_constraint_177},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct ErrorIndication_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_ErrorIndication_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_179, memb_criticality_constraint_177},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct ErrorIndication_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_180,
     select_ErrorIndication_IEs_value_type,
     {0, &asn_PER_memb_value_constr_180, memb_value_constraint_177},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_ErrorIndication_IEs_tags_177[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_ErrorIndication_IEs_tag2el_177[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_ErrorIndication_IEs_specs_177 = {
    sizeof(struct ErrorIndication_IEs),
    offsetof(struct ErrorIndication_IEs, _asn_ctx),
    asn_MAP_ErrorIndication_IEs_tag2el_177,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_ErrorIndication_IEs = {
    "ErrorIndication-IEs",
    "ErrorIndication-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_ErrorIndication_IEs_tags_177,
    sizeof(asn_DEF_ErrorIndication_IEs_tags_177) /
        sizeof(asn_DEF_ErrorIndication_IEs_tags_177[0]), /* 1 */
    asn_DEF_ErrorIndication_IEs_tags_177,                /* Same as above */
    sizeof(asn_DEF_ErrorIndication_IEs_tags_177) /
        sizeof(asn_DEF_ErrorIndication_IEs_tags_177[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_ErrorIndication_IEs_177,
    3,                                     /* Elements count */
    &asn_SPC_ErrorIndication_IEs_specs_177 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_184[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationRequest_IEs__value,
         choice.RequestedSRSTransmissionCharacteristics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_RequestedSRSTransmissionCharacteristics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "RequestedSRSTransmissionCharacteristics"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_184[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* RequestedSRSTransmissionCharacteristics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_184 = {
    sizeof(struct PositioningInformationRequest_IEs__value),
    offsetof(struct PositioningInformationRequest_IEs__value, _asn_ctx),
    offsetof(struct PositioningInformationRequest_IEs__value, present),
    sizeof(((struct PositioningInformationRequest_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_184,
    1, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_184 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_184,
        1,                       /* Elements count */
        &asn_SPC_value_specs_184 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningInformationRequest_IEs_181[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationRequest_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_182, memb_id_constraint_181},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationRequest_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningInformationRequest_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_183, memb_criticality_constraint_181},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationRequest_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_184,
     select_PositioningInformationRequest_IEs_value_type,
     {0, &asn_PER_memb_value_constr_184, memb_value_constraint_181},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_PositioningInformationRequest_IEs_tags_181[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningInformationRequest_IEs_tag2el_181[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningInformationRequest_IEs_specs_181 = {
    sizeof(struct PositioningInformationRequest_IEs),
    offsetof(struct PositioningInformationRequest_IEs, _asn_ctx),
    asn_MAP_PositioningInformationRequest_IEs_tag2el_181,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningInformationRequest_IEs = {
    "PositioningInformationRequest-IEs",
    "PositioningInformationRequest-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningInformationRequest_IEs_tags_181,
    sizeof(asn_DEF_PositioningInformationRequest_IEs_tags_181) /
        sizeof(asn_DEF_PositioningInformationRequest_IEs_tags_181[0]), /* 1 */
    asn_DEF_PositioningInformationRequest_IEs_tags_181, /* Same as above */
    sizeof(asn_DEF_PositioningInformationRequest_IEs_tags_181) /
        sizeof(asn_DEF_PositioningInformationRequest_IEs_tags_181[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningInformationRequest_IEs_181,
    3,                                                   /* Elements count */
    &asn_SPC_PositioningInformationRequest_IEs_specs_181 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_188[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationResponse_IEs__value,
         choice.SRSConfiguration),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_SRSConfiguration,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SRSConfiguration"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationResponse_IEs__value,
         choice.SFNInitialisationTime),
     (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
     0,
     &asn_DEF_SFNInitialisationTime,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SFNInitialisationTime"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationResponse_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_188[]        = {1, 0, 2};
static const unsigned asn_MAP_value_from_canonical_188[]      = {1, 0, 2};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_188[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 1, 0, 0}, /* SFNInitialisationTime */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 1}, /* SRSConfiguration */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, -1,
     0} /* CriticalityDiagnostics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_188 = {
    sizeof(struct PositioningInformationResponse_IEs__value),
    offsetof(struct PositioningInformationResponse_IEs__value, _asn_ctx),
    offsetof(struct PositioningInformationResponse_IEs__value, present),
    sizeof(((struct PositioningInformationResponse_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_188,
    3, /* Count of tags in the map */
    asn_MAP_value_to_canonical_188,
    asn_MAP_value_from_canonical_188,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_188 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_188,
        3,                       /* Elements count */
        &asn_SPC_value_specs_188 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningInformationResponse_IEs_185[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationResponse_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_186, memb_id_constraint_185},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationResponse_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningInformationResponse_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_187, memb_criticality_constraint_185},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationResponse_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_188,
     select_PositioningInformationResponse_IEs_value_type,
     {0, &asn_PER_memb_value_constr_188, memb_value_constraint_185},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_PositioningInformationResponse_IEs_tags_185[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningInformationResponse_IEs_tag2el_185[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningInformationResponse_IEs_specs_185 =
    {
        sizeof(struct PositioningInformationResponse_IEs),
        offsetof(struct PositioningInformationResponse_IEs, _asn_ctx),
        asn_MAP_PositioningInformationResponse_IEs_tag2el_185,
        3, /* Count of tags in the map */
        0,
        0,
        0,  /* Optional elements (not needed) */
        -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningInformationResponse_IEs = {
    "PositioningInformationResponse-IEs",
    "PositioningInformationResponse-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningInformationResponse_IEs_tags_185,
    sizeof(asn_DEF_PositioningInformationResponse_IEs_tags_185) /
        sizeof(asn_DEF_PositioningInformationResponse_IEs_tags_185[0]), /* 1 */
    asn_DEF_PositioningInformationResponse_IEs_tags_185, /* Same as above */
    sizeof(asn_DEF_PositioningInformationResponse_IEs_tags_185) /
        sizeof(asn_DEF_PositioningInformationResponse_IEs_tags_185[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningInformationResponse_IEs_185,
    3,                                                    /* Elements count */
    &asn_SPC_PositioningInformationResponse_IEs_specs_185 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_192[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationFailure_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationFailure_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_192[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_192[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_192[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 0, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_192 = {
    sizeof(struct PositioningInformationFailure_IEs__value),
    offsetof(struct PositioningInformationFailure_IEs__value, _asn_ctx),
    offsetof(struct PositioningInformationFailure_IEs__value, present),
    sizeof(((struct PositioningInformationFailure_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_192,
    5, /* Count of tags in the map */
    asn_MAP_value_to_canonical_192,
    asn_MAP_value_from_canonical_192,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_192 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_192,
        2,                       /* Elements count */
        &asn_SPC_value_specs_192 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningInformationFailure_IEs_189[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationFailure_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_190, memb_id_constraint_189},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationFailure_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningInformationFailure_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_191, memb_criticality_constraint_189},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationFailure_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_192,
     select_PositioningInformationFailure_IEs_value_type,
     {0, &asn_PER_memb_value_constr_192, memb_value_constraint_189},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t
    asn_DEF_PositioningInformationFailure_IEs_tags_189[] = {
        (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningInformationFailure_IEs_tag2el_189[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningInformationFailure_IEs_specs_189 = {
    sizeof(struct PositioningInformationFailure_IEs),
    offsetof(struct PositioningInformationFailure_IEs, _asn_ctx),
    asn_MAP_PositioningInformationFailure_IEs_tag2el_189,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningInformationFailure_IEs = {
    "PositioningInformationFailure-IEs",
    "PositioningInformationFailure-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningInformationFailure_IEs_tags_189,
    sizeof(asn_DEF_PositioningInformationFailure_IEs_tags_189) /
        sizeof(asn_DEF_PositioningInformationFailure_IEs_tags_189[0]), /* 1 */
    asn_DEF_PositioningInformationFailure_IEs_tags_189, /* Same as above */
    sizeof(asn_DEF_PositioningInformationFailure_IEs_tags_189) /
        sizeof(asn_DEF_PositioningInformationFailure_IEs_tags_189[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningInformationFailure_IEs_189,
    3,                                                   /* Elements count */
    &asn_SPC_PositioningInformationFailure_IEs_specs_189 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_196[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationUpdate_IEs__value,
         choice.SRSConfiguration),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_SRSConfiguration,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SRSConfiguration"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningInformationUpdate_IEs__value,
         choice.SFNInitialisationTime),
     (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
     0,
     &asn_DEF_SFNInitialisationTime,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SFNInitialisationTime"},
};
static const unsigned asn_MAP_value_to_canonical_196[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_196[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_196[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 1, 0, 0}, /* SFNInitialisationTime */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 0} /* SRSConfiguration */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_196 = {
    sizeof(struct PositioningInformationUpdate_IEs__value),
    offsetof(struct PositioningInformationUpdate_IEs__value, _asn_ctx),
    offsetof(struct PositioningInformationUpdate_IEs__value, present),
    sizeof(((struct PositioningInformationUpdate_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_196,
    2, /* Count of tags in the map */
    asn_MAP_value_to_canonical_196,
    asn_MAP_value_from_canonical_196,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_196 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_196,
        2,                       /* Elements count */
        &asn_SPC_value_specs_196 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningInformationUpdate_IEs_193[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationUpdate_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_194, memb_id_constraint_193},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationUpdate_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningInformationUpdate_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_195, memb_criticality_constraint_193},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningInformationUpdate_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_196,
     select_PositioningInformationUpdate_IEs_value_type,
     {0, &asn_PER_memb_value_constr_196, memb_value_constraint_193},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_PositioningInformationUpdate_IEs_tags_193[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningInformationUpdate_IEs_tag2el_193[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningInformationUpdate_IEs_specs_193 = {
    sizeof(struct PositioningInformationUpdate_IEs),
    offsetof(struct PositioningInformationUpdate_IEs, _asn_ctx),
    asn_MAP_PositioningInformationUpdate_IEs_tag2el_193,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningInformationUpdate_IEs = {
    "PositioningInformationUpdate-IEs",
    "PositioningInformationUpdate-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningInformationUpdate_IEs_tags_193,
    sizeof(asn_DEF_PositioningInformationUpdate_IEs_tags_193) /
        sizeof(asn_DEF_PositioningInformationUpdate_IEs_tags_193[0]), /* 1 */
    asn_DEF_PositioningInformationUpdate_IEs_tags_193, /* Same as above */
    sizeof(asn_DEF_PositioningInformationUpdate_IEs_tags_193) /
        sizeof(asn_DEF_PositioningInformationUpdate_IEs_tags_193[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningInformationUpdate_IEs_193,
    3,                                                  /* Elements count */
    &asn_SPC_PositioningInformationUpdate_IEs_specs_193 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_200[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementRequest_IEs__value,
         choice.TRP_MeasurementRequestList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRP_MeasurementRequestList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRP-MeasurementRequestList"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementRequest_IEs__value, choice.ReportCharacteristics),
     (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
     0,
     &asn_DEF_ReportCharacteristics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ReportCharacteristics"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementRequest_IEs__value, choice.MeasurementPeriodicity),
     (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
     0,
     &asn_DEF_MeasurementPeriodicity,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "MeasurementPeriodicity"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementRequest_IEs__value, choice.TRPMeasurementQuantities),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRPMeasurementQuantities,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRPMeasurementQuantities"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs__value, choice.SRSConfiguration),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_SRSConfiguration,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SRSConfiguration"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementRequest_IEs__value, choice.SFNInitialisationTime),
     (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
     0,
     &asn_DEF_SFNInitialisationTime,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SFNInitialisationTime"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementRequest_IEs__value,
         choice.MeasurementBeamInfoRequest),
     (ASN_TAG_CLASS_UNIVERSAL | (10 << 2)),
     0,
     &asn_DEF_MeasurementBeamInfoRequest,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "MeasurementBeamInfoRequest"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs__value, choice.SystemFrameNumber),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_SystemFrameNumber,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SystemFrameNumber"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs__value, choice.SlotNumber),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_SlotNumber,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SlotNumber"},
};
static const unsigned asn_MAP_value_to_canonical_200[]        = {0, 8, 9, 6, 2,
                                                          3, 7, 1, 4, 5};
static const unsigned asn_MAP_value_from_canonical_200[]      = {0, 7, 4, 5, 8,
                                                            9, 3, 6, 1, 2};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_200[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 2},  /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 8, -1, 1}, /* SystemFrameNumber */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 9, -2, 0}, /* SlotNumber */
    {(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 6, 0, 0}, /* SFNInitialisationTime */
    {(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 2, 0,
     2}, /* ReportCharacteristics */
    {(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 3, -1,
     1}, /* MeasurementPeriodicity */
    {(ASN_TAG_CLASS_UNIVERSAL | (10 << 2)), 7, -2,
     0}, /* MeasurementBeamInfoRequest */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0,
     2}, /* TRP-MeasurementRequestList */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 4, -1,
     1}, /* TRPMeasurementQuantities */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 5, -2, 0} /* SRSConfiguration */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_200 = {
    sizeof(struct MeasurementRequest_IEs__value),
    offsetof(struct MeasurementRequest_IEs__value, _asn_ctx),
    offsetof(struct MeasurementRequest_IEs__value, present),
    sizeof(((struct MeasurementRequest_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_200,
    10, /* Count of tags in the map */
    asn_MAP_value_to_canonical_200,
    asn_MAP_value_from_canonical_200,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_200 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_200,
        10,                      /* Elements count */
        &asn_SPC_value_specs_200 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementRequest_IEs_197[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_198, memb_id_constraint_197},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementRequest_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_199, memb_criticality_constraint_197},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementRequest_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_200,
     select_MeasurementRequest_IEs_value_type,
     {0, &asn_PER_memb_value_constr_200, memb_value_constraint_197},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementRequest_IEs_tags_197[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_MeasurementRequest_IEs_tag2el_197[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementRequest_IEs_specs_197 = {
    sizeof(struct MeasurementRequest_IEs),
    offsetof(struct MeasurementRequest_IEs, _asn_ctx),
    asn_MAP_MeasurementRequest_IEs_tag2el_197,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementRequest_IEs = {
    "MeasurementRequest-IEs",
    "MeasurementRequest-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementRequest_IEs_tags_197,
    sizeof(asn_DEF_MeasurementRequest_IEs_tags_197) /
        sizeof(asn_DEF_MeasurementRequest_IEs_tags_197[0]), /* 1 */
    asn_DEF_MeasurementRequest_IEs_tags_197,                /* Same as above */
    sizeof(asn_DEF_MeasurementRequest_IEs_tags_197) /
        sizeof(asn_DEF_MeasurementRequest_IEs_tags_197[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementRequest_IEs_197,
    3,                                        /* Elements count */
    &asn_SPC_MeasurementRequest_IEs_specs_197 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_204[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementResponse_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementResponse_IEs__value, choice.Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementResponse_IEs__value,
         choice.TRP_MeasurementResponseList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRP_MeasurementResponseList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRP-MeasurementResponseList"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementResponse_IEs__value, choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_204[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1},  /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0}, /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0,
     1}, /* TRP-MeasurementResponseList */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 3, -1,
     0} /* CriticalityDiagnostics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_204 = {
    sizeof(struct MeasurementResponse_IEs__value),
    offsetof(struct MeasurementResponse_IEs__value, _asn_ctx),
    offsetof(struct MeasurementResponse_IEs__value, present),
    sizeof(((struct MeasurementResponse_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_204,
    4, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_204 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_204,
        4,                       /* Elements count */
        &asn_SPC_value_specs_204 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementResponse_IEs_201[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementResponse_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_202, memb_id_constraint_201},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementResponse_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementResponse_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_203, memb_criticality_constraint_201},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementResponse_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_204,
     select_MeasurementResponse_IEs_value_type,
     {0, &asn_PER_memb_value_constr_204, memb_value_constraint_201},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementResponse_IEs_tags_201[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_MeasurementResponse_IEs_tag2el_201[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementResponse_IEs_specs_201 = {
    sizeof(struct MeasurementResponse_IEs),
    offsetof(struct MeasurementResponse_IEs, _asn_ctx),
    asn_MAP_MeasurementResponse_IEs_tag2el_201,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementResponse_IEs = {
    "MeasurementResponse-IEs",
    "MeasurementResponse-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementResponse_IEs_tags_201,
    sizeof(asn_DEF_MeasurementResponse_IEs_tags_201) /
        sizeof(asn_DEF_MeasurementResponse_IEs_tags_201[0]), /* 1 */
    asn_DEF_MeasurementResponse_IEs_tags_201,                /* Same as above */
    sizeof(asn_DEF_MeasurementResponse_IEs_tags_201) /
        sizeof(asn_DEF_MeasurementResponse_IEs_tags_201[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementResponse_IEs_201,
    3,                                         /* Elements count */
    &asn_SPC_MeasurementResponse_IEs_specs_201 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_208[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailure_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailure_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementFailure_IEs__value, choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_208[]        = {0, 2, 1};
static const unsigned asn_MAP_value_from_canonical_208[]      = {0, 2, 1};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_208[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 0}, /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 1, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 1, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 1, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_208 = {
    sizeof(struct MeasurementFailure_IEs__value),
    offsetof(struct MeasurementFailure_IEs__value, _asn_ctx),
    offsetof(struct MeasurementFailure_IEs__value, present),
    sizeof(((struct MeasurementFailure_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_208,
    6, /* Count of tags in the map */
    asn_MAP_value_to_canonical_208,
    asn_MAP_value_from_canonical_208,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_208 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_208,
        3,                       /* Elements count */
        &asn_SPC_value_specs_208 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementFailure_IEs_205[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailure_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_206, memb_id_constraint_205},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailure_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementFailure_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_207, memb_criticality_constraint_205},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailure_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_208,
     select_MeasurementFailure_IEs_value_type,
     {0, &asn_PER_memb_value_constr_208, memb_value_constraint_205},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementFailure_IEs_tags_205[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_MeasurementFailure_IEs_tag2el_205[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementFailure_IEs_specs_205 = {
    sizeof(struct MeasurementFailure_IEs),
    offsetof(struct MeasurementFailure_IEs, _asn_ctx),
    asn_MAP_MeasurementFailure_IEs_tag2el_205,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementFailure_IEs = {
    "MeasurementFailure-IEs",
    "MeasurementFailure-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementFailure_IEs_tags_205,
    sizeof(asn_DEF_MeasurementFailure_IEs_tags_205) /
        sizeof(asn_DEF_MeasurementFailure_IEs_tags_205[0]), /* 1 */
    asn_DEF_MeasurementFailure_IEs_tags_205,                /* Same as above */
    sizeof(asn_DEF_MeasurementFailure_IEs_tags_205) /
        sizeof(asn_DEF_MeasurementFailure_IEs_tags_205[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementFailure_IEs_205,
    3,                                        /* Elements count */
    &asn_SPC_MeasurementFailure_IEs_specs_205 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_212[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementReport_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementReport_IEs__value, choice.Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementReport_IEs__value,
         choice.TRP_MeasurementResponseList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRP_MeasurementResponseList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRP-MeasurementResponseList"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_212[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1},  /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0}, /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0,
     0} /* TRP-MeasurementResponseList */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_212 = {
    sizeof(struct MeasurementReport_IEs__value),
    offsetof(struct MeasurementReport_IEs__value, _asn_ctx),
    offsetof(struct MeasurementReport_IEs__value, present),
    sizeof(((struct MeasurementReport_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_212,
    3, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_212 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_212,
        3,                       /* Elements count */
        &asn_SPC_value_specs_212 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementReport_IEs_209[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementReport_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_210, memb_id_constraint_209},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementReport_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementReport_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_211, memb_criticality_constraint_209},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementReport_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_212,
     select_MeasurementReport_IEs_value_type,
     {0, &asn_PER_memb_value_constr_212, memb_value_constraint_209},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementReport_IEs_tags_209[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_MeasurementReport_IEs_tag2el_209[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementReport_IEs_specs_209 = {
    sizeof(struct MeasurementReport_IEs),
    offsetof(struct MeasurementReport_IEs, _asn_ctx),
    asn_MAP_MeasurementReport_IEs_tag2el_209,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementReport_IEs = {
    "MeasurementReport-IEs",
    "MeasurementReport-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementReport_IEs_tags_209,
    sizeof(asn_DEF_MeasurementReport_IEs_tags_209) /
        sizeof(asn_DEF_MeasurementReport_IEs_tags_209[0]), /* 1 */
    asn_DEF_MeasurementReport_IEs_tags_209,                /* Same as above */
    sizeof(asn_DEF_MeasurementReport_IEs_tags_209) /
        sizeof(asn_DEF_MeasurementReport_IEs_tags_209[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementReport_IEs_209,
    3,                                       /* Elements count */
    &asn_SPC_MeasurementReport_IEs_specs_209 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_216[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementUpdate_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementUpdate_IEs__value, choice.Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementUpdate_IEs__value, choice.SRSConfiguration),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_SRSConfiguration,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SRSConfiguration"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_216[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1},  /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0}, /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 2, 0, 0}  /* SRSConfiguration */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_216 = {
    sizeof(struct MeasurementUpdate_IEs__value),
    offsetof(struct MeasurementUpdate_IEs__value, _asn_ctx),
    offsetof(struct MeasurementUpdate_IEs__value, present),
    sizeof(((struct MeasurementUpdate_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_216,
    3, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_216 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_216,
        3,                       /* Elements count */
        &asn_SPC_value_specs_216 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementUpdate_IEs_213[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementUpdate_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_214, memb_id_constraint_213},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementUpdate_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementUpdate_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_215, memb_criticality_constraint_213},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementUpdate_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_216,
     select_MeasurementUpdate_IEs_value_type,
     {0, &asn_PER_memb_value_constr_216, memb_value_constraint_213},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementUpdate_IEs_tags_213[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_MeasurementUpdate_IEs_tag2el_213[] =
    {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementUpdate_IEs_specs_213 = {
    sizeof(struct MeasurementUpdate_IEs),
    offsetof(struct MeasurementUpdate_IEs, _asn_ctx),
    asn_MAP_MeasurementUpdate_IEs_tag2el_213,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementUpdate_IEs = {
    "MeasurementUpdate-IEs",
    "MeasurementUpdate-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementUpdate_IEs_tags_213,
    sizeof(asn_DEF_MeasurementUpdate_IEs_tags_213) /
        sizeof(asn_DEF_MeasurementUpdate_IEs_tags_213[0]), /* 1 */
    asn_DEF_MeasurementUpdate_IEs_tags_213,                /* Same as above */
    sizeof(asn_DEF_MeasurementUpdate_IEs_tags_213) /
        sizeof(asn_DEF_MeasurementUpdate_IEs_tags_213[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementUpdate_IEs_213,
    3,                                       /* Elements count */
    &asn_SPC_MeasurementUpdate_IEs_specs_213 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_220[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementAbort_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementAbort_IEs__value, choice.Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_220[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1}, /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0} /* Measurement-ID */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_220 = {
    sizeof(struct MeasurementAbort_IEs__value),
    offsetof(struct MeasurementAbort_IEs__value, _asn_ctx),
    offsetof(struct MeasurementAbort_IEs__value, present),
    sizeof(((struct MeasurementAbort_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_220,
    2, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_220 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_220,
        2,                       /* Elements count */
        &asn_SPC_value_specs_220 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementAbort_IEs_217[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementAbort_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_218, memb_id_constraint_217},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementAbort_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementAbort_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_219, memb_criticality_constraint_217},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementAbort_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_220,
     select_MeasurementAbort_IEs_value_type,
     {0, &asn_PER_memb_value_constr_220, memb_value_constraint_217},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementAbort_IEs_tags_217[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t asn_MAP_MeasurementAbort_IEs_tag2el_217[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementAbort_IEs_specs_217 = {
    sizeof(struct MeasurementAbort_IEs),
    offsetof(struct MeasurementAbort_IEs, _asn_ctx),
    asn_MAP_MeasurementAbort_IEs_tag2el_217,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementAbort_IEs = {
    "MeasurementAbort-IEs",
    "MeasurementAbort-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementAbort_IEs_tags_217,
    sizeof(asn_DEF_MeasurementAbort_IEs_tags_217) /
        sizeof(asn_DEF_MeasurementAbort_IEs_tags_217[0]), /* 1 */
    asn_DEF_MeasurementAbort_IEs_tags_217,                /* Same as above */
    sizeof(asn_DEF_MeasurementAbort_IEs_tags_217) /
        sizeof(asn_DEF_MeasurementAbort_IEs_tags_217[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementAbort_IEs_217,
    3,                                      /* Elements count */
    &asn_SPC_MeasurementAbort_IEs_specs_217 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_224[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementFailureIndication_IEs__value, choice.Measurement_ID),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct MeasurementFailureIndication_IEs__value,
         choice.Measurement_ID_1),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_Measurement_ID,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Measurement-ID"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailureIndication_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_224[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 0, 0, 1},  /* Measurement-ID */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, -1, 0}, /* Measurement-ID */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 2, 0, 0},    /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 2, 0, 0},    /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0},    /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 2, 0, 0}     /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_224 = {
    sizeof(struct MeasurementFailureIndication_IEs__value),
    offsetof(struct MeasurementFailureIndication_IEs__value, _asn_ctx),
    offsetof(struct MeasurementFailureIndication_IEs__value, present),
    sizeof(((struct MeasurementFailureIndication_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_224,
    6, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_224 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_224,
        3,                       /* Elements count */
        &asn_SPC_value_specs_224 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_MeasurementFailureIndication_IEs_221[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailureIndication_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_222, memb_id_constraint_221},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailureIndication_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_MeasurementFailureIndication_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_223, memb_criticality_constraint_221},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct MeasurementFailureIndication_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_224,
     select_MeasurementFailureIndication_IEs_value_type,
     {0, &asn_PER_memb_value_constr_224, memb_value_constraint_221},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_MeasurementFailureIndication_IEs_tags_221[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_MeasurementFailureIndication_IEs_tag2el_221[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_MeasurementFailureIndication_IEs_specs_221 = {
    sizeof(struct MeasurementFailureIndication_IEs),
    offsetof(struct MeasurementFailureIndication_IEs, _asn_ctx),
    asn_MAP_MeasurementFailureIndication_IEs_tag2el_221,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_MeasurementFailureIndication_IEs = {
    "MeasurementFailureIndication-IEs",
    "MeasurementFailureIndication-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_MeasurementFailureIndication_IEs_tags_221,
    sizeof(asn_DEF_MeasurementFailureIndication_IEs_tags_221) /
        sizeof(asn_DEF_MeasurementFailureIndication_IEs_tags_221[0]), /* 1 */
    asn_DEF_MeasurementFailureIndication_IEs_tags_221, /* Same as above */
    sizeof(asn_DEF_MeasurementFailureIndication_IEs_tags_221) /
        sizeof(asn_DEF_MeasurementFailureIndication_IEs_tags_221[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_MeasurementFailureIndication_IEs_221,
    3,                                                  /* Elements count */
    &asn_SPC_MeasurementFailureIndication_IEs_specs_221 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_228[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationRequest_IEs__value, choice.TRPList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRPList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRPList"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct TRPInformationRequest_IEs__value,
         choice.TRPInformationTypeList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRPInformationTypeList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRPInformationTypeList"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_228[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 1}, /* TRPList */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1,
     0} /* TRPInformationTypeList */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_228 = {
    sizeof(struct TRPInformationRequest_IEs__value),
    offsetof(struct TRPInformationRequest_IEs__value, _asn_ctx),
    offsetof(struct TRPInformationRequest_IEs__value, present),
    sizeof(((struct TRPInformationRequest_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_228,
    2, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_228 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_228,
        2,                       /* Elements count */
        &asn_SPC_value_specs_228 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPInformationRequest_IEs_225[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationRequest_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_226, memb_id_constraint_225},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationRequest_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_TRPInformationRequest_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_227, memb_criticality_constraint_225},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationRequest_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_228,
     select_TRPInformationRequest_IEs_value_type,
     {0, &asn_PER_memb_value_constr_228, memb_value_constraint_225},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPInformationRequest_IEs_tags_225[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPInformationRequest_IEs_tag2el_225[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPInformationRequest_IEs_specs_225 = {
    sizeof(struct TRPInformationRequest_IEs),
    offsetof(struct TRPInformationRequest_IEs, _asn_ctx),
    asn_MAP_TRPInformationRequest_IEs_tag2el_225,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPInformationRequest_IEs = {
    "TRPInformationRequest-IEs",
    "TRPInformationRequest-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPInformationRequest_IEs_tags_225,
    sizeof(asn_DEF_TRPInformationRequest_IEs_tags_225) /
        sizeof(asn_DEF_TRPInformationRequest_IEs_tags_225[0]), /* 1 */
    asn_DEF_TRPInformationRequest_IEs_tags_225, /* Same as above */
    sizeof(asn_DEF_TRPInformationRequest_IEs_tags_225) /
        sizeof(asn_DEF_TRPInformationRequest_IEs_tags_225[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPInformationRequest_IEs_225,
    3,                                           /* Elements count */
    &asn_SPC_TRPInformationRequest_IEs_specs_225 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_232[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct TRPInformationResponse_IEs__value, choice.TRPInformationList),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_TRPInformationList,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "TRPInformationList"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct TRPInformationResponse_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_232[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0, 1}, /* TRPInformationList */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, -1,
     0} /* CriticalityDiagnostics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_232 = {
    sizeof(struct TRPInformationResponse_IEs__value),
    offsetof(struct TRPInformationResponse_IEs__value, _asn_ctx),
    offsetof(struct TRPInformationResponse_IEs__value, present),
    sizeof(((struct TRPInformationResponse_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_232,
    2, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_232 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_232,
        2,                       /* Elements count */
        &asn_SPC_value_specs_232 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPInformationResponse_IEs_229[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationResponse_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_230, memb_id_constraint_229},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationResponse_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_TRPInformationResponse_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_231, memb_criticality_constraint_229},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationResponse_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_232,
     select_TRPInformationResponse_IEs_value_type,
     {0, &asn_PER_memb_value_constr_232, memb_value_constraint_229},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPInformationResponse_IEs_tags_229[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPInformationResponse_IEs_tag2el_229[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPInformationResponse_IEs_specs_229 = {
    sizeof(struct TRPInformationResponse_IEs),
    offsetof(struct TRPInformationResponse_IEs, _asn_ctx),
    asn_MAP_TRPInformationResponse_IEs_tag2el_229,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPInformationResponse_IEs = {
    "TRPInformationResponse-IEs",
    "TRPInformationResponse-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPInformationResponse_IEs_tags_229,
    sizeof(asn_DEF_TRPInformationResponse_IEs_tags_229) /
        sizeof(asn_DEF_TRPInformationResponse_IEs_tags_229[0]), /* 1 */
    asn_DEF_TRPInformationResponse_IEs_tags_229, /* Same as above */
    sizeof(asn_DEF_TRPInformationResponse_IEs_tags_229) /
        sizeof(asn_DEF_TRPInformationResponse_IEs_tags_229[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPInformationResponse_IEs_229,
    3,                                            /* Elements count */
    &asn_SPC_TRPInformationResponse_IEs_specs_229 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_236[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationFailure_IEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct TRPInformationFailure_IEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_236[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_236[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_236[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 0, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_236 = {
    sizeof(struct TRPInformationFailure_IEs__value),
    offsetof(struct TRPInformationFailure_IEs__value, _asn_ctx),
    offsetof(struct TRPInformationFailure_IEs__value, present),
    sizeof(((struct TRPInformationFailure_IEs__value*) 0)->present),
    asn_MAP_value_tag2el_236,
    5, /* Count of tags in the map */
    asn_MAP_value_to_canonical_236,
    asn_MAP_value_from_canonical_236,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_236 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_236,
        2,                       /* Elements count */
        &asn_SPC_value_specs_236 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_TRPInformationFailure_IEs_233[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationFailure_IEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_234, memb_id_constraint_233},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationFailure_IEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_TRPInformationFailure_IEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_235, memb_criticality_constraint_233},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct TRPInformationFailure_IEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_236,
     select_TRPInformationFailure_IEs_value_type,
     {0, &asn_PER_memb_value_constr_236, memb_value_constraint_233},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_TRPInformationFailure_IEs_tags_233[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_TRPInformationFailure_IEs_tag2el_233[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_TRPInformationFailure_IEs_specs_233 = {
    sizeof(struct TRPInformationFailure_IEs),
    offsetof(struct TRPInformationFailure_IEs, _asn_ctx),
    asn_MAP_TRPInformationFailure_IEs_tag2el_233,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_TRPInformationFailure_IEs = {
    "TRPInformationFailure-IEs",
    "TRPInformationFailure-IEs",
    &asn_OP_SEQUENCE,
    asn_DEF_TRPInformationFailure_IEs_tags_233,
    sizeof(asn_DEF_TRPInformationFailure_IEs_tags_233) /
        sizeof(asn_DEF_TRPInformationFailure_IEs_tags_233[0]), /* 1 */
    asn_DEF_TRPInformationFailure_IEs_tags_233, /* Same as above */
    sizeof(asn_DEF_TRPInformationFailure_IEs_tags_233) /
        sizeof(asn_DEF_TRPInformationFailure_IEs_tags_233[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_TRPInformationFailure_IEs_233,
    3,                                           /* Elements count */
    &asn_SPC_TRPInformationFailure_IEs_specs_233 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_240[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationRequestIEs__value, choice.SRSType),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_SRSType,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SRSType"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningActivationRequestIEs__value, choice.ActivationTime),
     (ASN_TAG_CLASS_UNIVERSAL | (3 << 2)),
     0,
     &asn_DEF_ActivationTime,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "ActivationTime"},
};
static const unsigned asn_MAP_value_to_canonical_240[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_240[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_240[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (3 << 2)), 1, 0, 0}, /* ActivationTime */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0},   /* semipersistentSRS */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0},   /* aperiodicSRS */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}    /* sRSType-extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_240 = {
    sizeof(struct PositioningActivationRequestIEs__value),
    offsetof(struct PositioningActivationRequestIEs__value, _asn_ctx),
    offsetof(struct PositioningActivationRequestIEs__value, present),
    sizeof(((struct PositioningActivationRequestIEs__value*) 0)->present),
    asn_MAP_value_tag2el_240,
    4, /* Count of tags in the map */
    asn_MAP_value_to_canonical_240,
    asn_MAP_value_from_canonical_240,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_240 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_240,
        2,                       /* Elements count */
        &asn_SPC_value_specs_240 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningActivationRequestIEs_237[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationRequestIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_238, memb_id_constraint_237},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationRequestIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningActivationRequestIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_239, memb_criticality_constraint_237},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationRequestIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_240,
     select_PositioningActivationRequestIEs_value_type,
     {0, &asn_PER_memb_value_constr_240, memb_value_constraint_237},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_PositioningActivationRequestIEs_tags_237[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningActivationRequestIEs_tag2el_237[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningActivationRequestIEs_specs_237 = {
    sizeof(struct PositioningActivationRequestIEs),
    offsetof(struct PositioningActivationRequestIEs, _asn_ctx),
    asn_MAP_PositioningActivationRequestIEs_tag2el_237,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningActivationRequestIEs = {
    "PositioningActivationRequestIEs",
    "PositioningActivationRequestIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningActivationRequestIEs_tags_237,
    sizeof(asn_DEF_PositioningActivationRequestIEs_tags_237) /
        sizeof(asn_DEF_PositioningActivationRequestIEs_tags_237[0]), /* 1 */
    asn_DEF_PositioningActivationRequestIEs_tags_237, /* Same as above */
    sizeof(asn_DEF_PositioningActivationRequestIEs_tags_237) /
        sizeof(asn_DEF_PositioningActivationRequestIEs_tags_237[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningActivationRequestIEs_237,
    3,                                                 /* Elements count */
    &asn_SPC_PositioningActivationRequestIEs_specs_237 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_244[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningActivationResponseIEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningActivationResponseIEs__value,
         choice.SystemFrameNumber),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_SystemFrameNumber,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SystemFrameNumber"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningActivationResponseIEs__value, choice.SlotNumber),
     (ASN_TAG_CLASS_UNIVERSAL | (2 << 2)),
     0,
     &asn_DEF_SlotNumber,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "SlotNumber"},
};
static const unsigned asn_MAP_value_to_canonical_244[]        = {1, 2, 0};
static const unsigned asn_MAP_value_from_canonical_244[]      = {2, 0, 1};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_244[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 1, 0, 1},  /* SystemFrameNumber */
    {(ASN_TAG_CLASS_UNIVERSAL | (2 << 2)), 2, -1, 0}, /* SlotNumber */
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 0, 0,
     0} /* CriticalityDiagnostics */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_244 = {
    sizeof(struct PositioningActivationResponseIEs__value),
    offsetof(struct PositioningActivationResponseIEs__value, _asn_ctx),
    offsetof(struct PositioningActivationResponseIEs__value, present),
    sizeof(((struct PositioningActivationResponseIEs__value*) 0)->present),
    asn_MAP_value_tag2el_244,
    3, /* Count of tags in the map */
    asn_MAP_value_to_canonical_244,
    asn_MAP_value_from_canonical_244,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_244 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_244,
        3,                       /* Elements count */
        &asn_SPC_value_specs_244 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningActivationResponseIEs_241[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationResponseIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_242, memb_id_constraint_241},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationResponseIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningActivationResponseIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_243, memb_criticality_constraint_241},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationResponseIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_244,
     select_PositioningActivationResponseIEs_value_type,
     {0, &asn_PER_memb_value_constr_244, memb_value_constraint_241},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_PositioningActivationResponseIEs_tags_241[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningActivationResponseIEs_tag2el_241[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningActivationResponseIEs_specs_241 = {
    sizeof(struct PositioningActivationResponseIEs),
    offsetof(struct PositioningActivationResponseIEs, _asn_ctx),
    asn_MAP_PositioningActivationResponseIEs_tag2el_241,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningActivationResponseIEs = {
    "PositioningActivationResponseIEs",
    "PositioningActivationResponseIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningActivationResponseIEs_tags_241,
    sizeof(asn_DEF_PositioningActivationResponseIEs_tags_241) /
        sizeof(asn_DEF_PositioningActivationResponseIEs_tags_241[0]), /* 1 */
    asn_DEF_PositioningActivationResponseIEs_tags_241, /* Same as above */
    sizeof(asn_DEF_PositioningActivationResponseIEs_tags_241) /
        sizeof(asn_DEF_PositioningActivationResponseIEs_tags_241[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningActivationResponseIEs_241,
    3,                                                  /* Elements count */
    &asn_SPC_PositioningActivationResponseIEs_specs_241 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_248[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationFailureIEs__value, choice.Cause),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_Cause,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "Cause"},
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningActivationFailureIEs__value,
         choice.CriticalityDiagnostics),
     (ASN_TAG_CLASS_UNIVERSAL | (16 << 2)),
     0,
     &asn_DEF_CriticalityDiagnostics,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "CriticalityDiagnostics"},
};
static const unsigned asn_MAP_value_to_canonical_248[]        = {1, 0};
static const unsigned asn_MAP_value_from_canonical_248[]      = {1, 0};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_248[] = {
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2)), 1, 0,
     0},                                           /* CriticalityDiagnostics */
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* radioNetwork */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0}, /* protocol */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}, /* misc */
    {(ASN_TAG_CLASS_CONTEXT | (3 << 2)), 0, 0, 0}  /* cause-Extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_248 = {
    sizeof(struct PositioningActivationFailureIEs__value),
    offsetof(struct PositioningActivationFailureIEs__value, _asn_ctx),
    offsetof(struct PositioningActivationFailureIEs__value, present),
    sizeof(((struct PositioningActivationFailureIEs__value*) 0)->present),
    asn_MAP_value_tag2el_248,
    5, /* Count of tags in the map */
    asn_MAP_value_to_canonical_248,
    asn_MAP_value_from_canonical_248,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_248 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_248,
        2,                       /* Elements count */
        &asn_SPC_value_specs_248 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningActivationFailureIEs_245[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationFailureIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_246, memb_id_constraint_245},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationFailureIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningActivationFailureIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_247, memb_criticality_constraint_245},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningActivationFailureIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_248,
     select_PositioningActivationFailureIEs_value_type,
     {0, &asn_PER_memb_value_constr_248, memb_value_constraint_245},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_PositioningActivationFailureIEs_tags_245[] =
    {(ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningActivationFailureIEs_tag2el_245[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningActivationFailureIEs_specs_245 = {
    sizeof(struct PositioningActivationFailureIEs),
    offsetof(struct PositioningActivationFailureIEs, _asn_ctx),
    asn_MAP_PositioningActivationFailureIEs_tag2el_245,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningActivationFailureIEs = {
    "PositioningActivationFailureIEs",
    "PositioningActivationFailureIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningActivationFailureIEs_tags_245,
    sizeof(asn_DEF_PositioningActivationFailureIEs_tags_245) /
        sizeof(asn_DEF_PositioningActivationFailureIEs_tags_245[0]), /* 1 */
    asn_DEF_PositioningActivationFailureIEs_tags_245, /* Same as above */
    sizeof(asn_DEF_PositioningActivationFailureIEs_tags_245) /
        sizeof(asn_DEF_PositioningActivationFailureIEs_tags_245[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningActivationFailureIEs_245,
    3,                                                 /* Elements count */
    &asn_SPC_PositioningActivationFailureIEs_specs_245 /* Additional specs */
};

static asn_TYPE_member_t asn_MBR_value_252[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(
         struct PositioningDeactivationIEs__value, choice.AbortTransmission),
     -1 /* Ambiguous tag (CHOICE?) */,
     0,
     &asn_DEF_AbortTransmission,
     0,
     {0, 0, 0},
     0,
     0, /* No default value */
     "AbortTransmission"},
};
static const asn_TYPE_tag2member_t asn_MAP_value_tag2el_252[] = {
    {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* sRSResourceSetID */
    {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 0, 0, 0}, /* releaseALL */
    {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 0, 0, 0}  /* choice-extension */
};
static asn_CHOICE_specifics_t asn_SPC_value_specs_252 = {
    sizeof(struct PositioningDeactivationIEs__value),
    offsetof(struct PositioningDeactivationIEs__value, _asn_ctx),
    offsetof(struct PositioningDeactivationIEs__value, present),
    sizeof(((struct PositioningDeactivationIEs__value*) 0)->present),
    asn_MAP_value_tag2el_252,
    3, /* Count of tags in the map */
    0,
    0,
    -1 /* Extensions start */
};
static /* Use -fall-defs-global to expose */
    asn_TYPE_descriptor_t asn_DEF_value_252 = {
        "value",
        "value",
        &asn_OP_OPEN_TYPE,
        0, /* No effective tags (pointer) */
        0, /* No effective tags (count) */
        0, /* No tags (pointer) */
        0, /* No tags (count) */
        {0, 0, OPEN_TYPE_constraint},
        asn_MBR_value_252,
        1,                       /* Elements count */
        &asn_SPC_value_specs_252 /* Additional specs */
};

asn_TYPE_member_t asn_MBR_PositioningDeactivationIEs_249[] = {
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningDeactivationIEs, id),
     (ASN_TAG_CLASS_CONTEXT | (0 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_ProtocolIE_ID,
     0,
     {0, &asn_PER_memb_id_constr_250, memb_id_constraint_249},
     0,
     0, /* No default value */
     "id"},
    {ATF_NOFLAGS,
     0,
     offsetof(struct PositioningDeactivationIEs, criticality),
     (ASN_TAG_CLASS_CONTEXT | (1 << 2)),
     -1, /* IMPLICIT tag at current level */
     &asn_DEF_Criticality,
     select_PositioningDeactivationIEs_criticality_type,
     {0, &asn_PER_memb_criticality_constr_251, memb_criticality_constraint_249},
     0,
     0, /* No default value */
     "criticality"},
    {ATF_OPEN_TYPE | ATF_NOFLAGS,
     0,
     offsetof(struct PositioningDeactivationIEs, value),
     (ASN_TAG_CLASS_CONTEXT | (2 << 2)),
     +1, /* EXPLICIT tag at current level */
     &asn_DEF_value_252,
     select_PositioningDeactivationIEs_value_type,
     {0, &asn_PER_memb_value_constr_252, memb_value_constraint_249},
     0,
     0, /* No default value */
     "value"},
};
static const ber_tlv_tag_t asn_DEF_PositioningDeactivationIEs_tags_249[] = {
    (ASN_TAG_CLASS_UNIVERSAL | (16 << 2))};
static const asn_TYPE_tag2member_t
    asn_MAP_PositioningDeactivationIEs_tag2el_249[] = {
        {(ASN_TAG_CLASS_CONTEXT | (0 << 2)), 0, 0, 0}, /* id */
        {(ASN_TAG_CLASS_CONTEXT | (1 << 2)), 1, 0, 0}, /* criticality */
        {(ASN_TAG_CLASS_CONTEXT | (2 << 2)), 2, 0, 0}  /* value */
};
asn_SEQUENCE_specifics_t asn_SPC_PositioningDeactivationIEs_specs_249 = {
    sizeof(struct PositioningDeactivationIEs),
    offsetof(struct PositioningDeactivationIEs, _asn_ctx),
    asn_MAP_PositioningDeactivationIEs_tag2el_249,
    3, /* Count of tags in the map */
    0,
    0,
    0,  /* Optional elements (not needed) */
    -1, /* First extension addition */
};
asn_TYPE_descriptor_t asn_DEF_PositioningDeactivationIEs = {
    "PositioningDeactivationIEs",
    "PositioningDeactivationIEs",
    &asn_OP_SEQUENCE,
    asn_DEF_PositioningDeactivationIEs_tags_249,
    sizeof(asn_DEF_PositioningDeactivationIEs_tags_249) /
        sizeof(asn_DEF_PositioningDeactivationIEs_tags_249[0]), /* 1 */
    asn_DEF_PositioningDeactivationIEs_tags_249, /* Same as above */
    sizeof(asn_DEF_PositioningDeactivationIEs_tags_249) /
        sizeof(asn_DEF_PositioningDeactivationIEs_tags_249[0]), /* 1 */
    {0, 0, SEQUENCE_constraint},
    asn_MBR_PositioningDeactivationIEs_249,
    3,                                            /* Elements count */
    &asn_SPC_PositioningDeactivationIEs_specs_249 /* Additional specs */
};
