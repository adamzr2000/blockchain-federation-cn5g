/**
 * LMF Location
 * LMF Location Service. Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA,
 * ETSI, TSDSI, TTA, TTC). All rights reserved.
 *
 * The version of the OpenAPI document: 1.1.5
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "AreaEventInfo.h"
#include "Helpers.h"

#include <sstream>

namespace oai::model::lmf {

AreaEventInfo::AreaEventInfo() {
  m_OccurrenceInfoIsSet       = false;
  m_MinimumInterval           = 0;
  m_MinimumIntervalIsSet      = false;
  m_MaximumInterval           = 0;
  m_MaximumIntervalIsSet      = false;
  m_SamplingInterval          = 0;
  m_SamplingIntervalIsSet     = false;
  m_ReportingDuration         = 0;
  m_ReportingDurationIsSet    = false;
  m_ReportingLocationReq      = true;
  m_ReportingLocationReqIsSet = false;
}

void AreaEventInfo::validate() const {
  std::stringstream msg;
  if (!validate(msg)) {
    throw oai::model::common::helpers::ValidationException(msg.str());
  }
}

bool AreaEventInfo::validate(std::stringstream& msg) const {
  return validate(msg, "");
}

bool AreaEventInfo::validate(
    std::stringstream& msg, const std::string& pathPrefix) const {
  bool success = true;
  const std::string _pathPrefix =
      pathPrefix.empty() ? "AreaEventInfo" : pathPrefix;

  /* AreaDefinition */ {
    const std::vector<oai::model::lmf::ReportingArea>& value = m_AreaDefinition;
    const std::string currentValuePath = _pathPrefix + ".areaDefinition";

    if (value.size() < 1) {
      success = false;
      msg << currentValuePath << ": must have at least 1 elements;";
    }
    if (value.size() > 250) {
      success = false;
      msg << currentValuePath << ": must have at most 250 elements;";
    }
    {  // Recursive validation of array elements
      const std::string oldValuePath = currentValuePath;
      int i                          = 0;
      for (const oai::model::lmf::ReportingArea& value : value) {
        const std::string currentValuePath =
            oldValuePath + "[" + std::to_string(i) + "]";

        success = value.validate(msg, currentValuePath + ".areaDefinition") &&
                  success;

        i++;
      }
    }
  }

  if (minimumIntervalIsSet()) {
    const int32_t& value               = m_MinimumInterval;
    const std::string currentValuePath = _pathPrefix + ".minimumInterval";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 32767) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 32767;";
    }
  }

  if (maximumIntervalIsSet()) {
    const int32_t& value               = m_MaximumInterval;
    const std::string currentValuePath = _pathPrefix + ".maximumInterval";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 86400) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 86400;";
    }
  }

  if (samplingIntervalIsSet()) {
    const int32_t& value               = m_SamplingInterval;
    const std::string currentValuePath = _pathPrefix + ".samplingInterval";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 3600) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 3600;";
    }
  }

  if (reportingDurationIsSet()) {
    const int32_t& value               = m_ReportingDuration;
    const std::string currentValuePath = _pathPrefix + ".reportingDuration";

    if (value < 1) {
      success = false;
      msg << currentValuePath << ": must be greater than or equal to 1;";
    }
    if (value > 8640000) {
      success = false;
      msg << currentValuePath << ": must be less than or equal to 8640000;";
    }
  }

  return success;
}

bool AreaEventInfo::operator==(const AreaEventInfo& rhs) const {
  return

      (getAreaDefinition() == rhs.getAreaDefinition()) &&

      ((!occurrenceInfoIsSet() && !rhs.occurrenceInfoIsSet()) ||
       (occurrenceInfoIsSet() && rhs.occurrenceInfoIsSet() &&
        getOccurrenceInfo() == rhs.getOccurrenceInfo())) &&

      ((!minimumIntervalIsSet() && !rhs.minimumIntervalIsSet()) ||
       (minimumIntervalIsSet() && rhs.minimumIntervalIsSet() &&
        getMinimumInterval() == rhs.getMinimumInterval())) &&

      ((!maximumIntervalIsSet() && !rhs.maximumIntervalIsSet()) ||
       (maximumIntervalIsSet() && rhs.maximumIntervalIsSet() &&
        getMaximumInterval() == rhs.getMaximumInterval())) &&

      ((!samplingIntervalIsSet() && !rhs.samplingIntervalIsSet()) ||
       (samplingIntervalIsSet() && rhs.samplingIntervalIsSet() &&
        getSamplingInterval() == rhs.getSamplingInterval())) &&

      ((!reportingDurationIsSet() && !rhs.reportingDurationIsSet()) ||
       (reportingDurationIsSet() && rhs.reportingDurationIsSet() &&
        getReportingDuration() == rhs.getReportingDuration())) &&

      ((!reportingLocationReqIsSet() && !rhs.reportingLocationReqIsSet()) ||
       (reportingLocationReqIsSet() && rhs.reportingLocationReqIsSet() &&
        isReportingLocationReq() == rhs.isReportingLocationReq()))

          ;
}

bool AreaEventInfo::operator!=(const AreaEventInfo& rhs) const {
  return !(*this == rhs);
}

void to_json(nlohmann::json& j, const AreaEventInfo& o) {
  j                   = nlohmann::json();
  j["areaDefinition"] = o.m_AreaDefinition;
  if (o.occurrenceInfoIsSet()) j["occurrenceInfo"] = o.m_OccurrenceInfo;
  if (o.minimumIntervalIsSet()) j["minimumInterval"] = o.m_MinimumInterval;
  if (o.maximumIntervalIsSet()) j["maximumInterval"] = o.m_MaximumInterval;
  if (o.samplingIntervalIsSet()) j["samplingInterval"] = o.m_SamplingInterval;
  if (o.reportingDurationIsSet())
    j["reportingDuration"] = o.m_ReportingDuration;
  if (o.reportingLocationReqIsSet())
    j["reportingLocationReq"] = o.m_ReportingLocationReq;
}

void from_json(const nlohmann::json& j, AreaEventInfo& o) {
  j.at("areaDefinition").get_to(o.m_AreaDefinition);
  if (j.find("occurrenceInfo") != j.end()) {
    j.at("occurrenceInfo").get_to(o.m_OccurrenceInfo);
    o.m_OccurrenceInfoIsSet = true;
  }
  if (j.find("minimumInterval") != j.end()) {
    j.at("minimumInterval").get_to(o.m_MinimumInterval);
    o.m_MinimumIntervalIsSet = true;
  }
  if (j.find("maximumInterval") != j.end()) {
    j.at("maximumInterval").get_to(o.m_MaximumInterval);
    o.m_MaximumIntervalIsSet = true;
  }
  if (j.find("samplingInterval") != j.end()) {
    j.at("samplingInterval").get_to(o.m_SamplingInterval);
    o.m_SamplingIntervalIsSet = true;
  }
  if (j.find("reportingDuration") != j.end()) {
    j.at("reportingDuration").get_to(o.m_ReportingDuration);
    o.m_ReportingDurationIsSet = true;
  }
  if (j.find("reportingLocationReq") != j.end()) {
    j.at("reportingLocationReq").get_to(o.m_ReportingLocationReq);
    o.m_ReportingLocationReqIsSet = true;
  }
}

std::vector<oai::model::lmf::ReportingArea> AreaEventInfo::getAreaDefinition()
    const {
  return m_AreaDefinition;
}
void AreaEventInfo::setAreaDefinition(
    std::vector<oai::model::lmf::ReportingArea> const& value) {
  m_AreaDefinition = value;
}
oai::model::lmf::OccurrenceInfo AreaEventInfo::getOccurrenceInfo() const {
  return m_OccurrenceInfo;
}
void AreaEventInfo::setOccurrenceInfo(
    oai::model::lmf::OccurrenceInfo const& value) {
  m_OccurrenceInfo      = value;
  m_OccurrenceInfoIsSet = true;
}
bool AreaEventInfo::occurrenceInfoIsSet() const {
  return m_OccurrenceInfoIsSet;
}
void AreaEventInfo::unsetOccurrenceInfo() {
  m_OccurrenceInfoIsSet = false;
}
int32_t AreaEventInfo::getMinimumInterval() const {
  return m_MinimumInterval;
}
void AreaEventInfo::setMinimumInterval(int32_t const value) {
  m_MinimumInterval      = value;
  m_MinimumIntervalIsSet = true;
}
bool AreaEventInfo::minimumIntervalIsSet() const {
  return m_MinimumIntervalIsSet;
}
void AreaEventInfo::unsetMinimumInterval() {
  m_MinimumIntervalIsSet = false;
}
int32_t AreaEventInfo::getMaximumInterval() const {
  return m_MaximumInterval;
}
void AreaEventInfo::setMaximumInterval(int32_t const value) {
  m_MaximumInterval      = value;
  m_MaximumIntervalIsSet = true;
}
bool AreaEventInfo::maximumIntervalIsSet() const {
  return m_MaximumIntervalIsSet;
}
void AreaEventInfo::unsetMaximumInterval() {
  m_MaximumIntervalIsSet = false;
}
int32_t AreaEventInfo::getSamplingInterval() const {
  return m_SamplingInterval;
}
void AreaEventInfo::setSamplingInterval(int32_t const value) {
  m_SamplingInterval      = value;
  m_SamplingIntervalIsSet = true;
}
bool AreaEventInfo::samplingIntervalIsSet() const {
  return m_SamplingIntervalIsSet;
}
void AreaEventInfo::unsetSamplingInterval() {
  m_SamplingIntervalIsSet = false;
}
int32_t AreaEventInfo::getReportingDuration() const {
  return m_ReportingDuration;
}
void AreaEventInfo::setReportingDuration(int32_t const value) {
  m_ReportingDuration      = value;
  m_ReportingDurationIsSet = true;
}
bool AreaEventInfo::reportingDurationIsSet() const {
  return m_ReportingDurationIsSet;
}
void AreaEventInfo::unsetReportingDuration() {
  m_ReportingDurationIsSet = false;
}
bool AreaEventInfo::isReportingLocationReq() const {
  return m_ReportingLocationReq;
}
void AreaEventInfo::setReportingLocationReq(bool const value) {
  m_ReportingLocationReq      = value;
  m_ReportingLocationReqIsSet = true;
}
bool AreaEventInfo::reportingLocationReqIsSet() const {
  return m_ReportingLocationReqIsSet;
}
void AreaEventInfo::unsetReportingLocationReq() {
  m_ReportingLocationReqIsSet = false;
}

}  // namespace oai::model::lmf
